### CODEBUNDLE generated: 2025-10-01 13:19:41 -04:00


===== START FILE: .cleanup_backup_20250929_133615\app\__init__.py =====


===== END FILE: .cleanup_backup_20250929_133615\app\__init__.py =====


===== START FILE: .cleanup_backup_20250929_133615\app\routers_phase9.py =====
from __future__ import annotations
import sys, os
from fastapi import APIRouter

# Ensure project root is on sys.path so "backend" can be imported regardless of where uvicorn was launched
ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

def include_phase9(app):
    try:
        from backend.controllers.moderation_controller import router as moderation_router
        from backend.controllers.report_controller import router as report_router
    except Exception as e:
        # Expose the import error so we can see it quickly via probe
        moderation_router = None
        report_router = None
        import_error = str(e)
    else:
        import_error = None
        app.include_router(moderation_router)
        app.include_router(report_router)

    probe = APIRouter()
    @probe.get("/__phase9_probe")
    def _probe():
        return {"ok": True, "routers": ["moderation","reports"], "import_error": import_error}

    @probe.get("/__routes")
    def _routes():
        try:
            return {"routes": [getattr(r, "path", str(r)) for r in app.routes]}
        except Exception as e:
            return {"error": str(e)}

    app.include_router(probe)

===== END FILE: .cleanup_backup_20250929_133615\app\routers_phase9.py =====


===== START FILE: .cleanup_backup_20250929_133615\controllers\__init__.py =====


===== END FILE: .cleanup_backup_20250929_133615\controllers\__init__.py =====


===== START FILE: .cleanup_backup_20250929_133615\routes\__init__.py =====


===== END FILE: .cleanup_backup_20250929_133615\routes\__init__.py =====


===== START FILE: .cleanup_backup_20250929_133615\routes\moderation_routes.py =====
from backend.controllers.moderation_controller import router as moderation_router


===== END FILE: .cleanup_backup_20250929_133615\routes\moderation_routes.py =====


===== START FILE: .cleanup_backup_20250929_133615\routes\report_routes.py =====
from backend.controllers.report_controller import router as report_router


===== END FILE: .cleanup_backup_20250929_133615\routes\report_routes.py =====


===== START FILE: backend\__init__.py =====
===== END FILE: backend\__init__.py =====


===== START FILE: backend\alembic.ini =====
# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to alembic/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = %(DATABASE_URL)s


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

===== END FILE: backend\alembic.ini =====


===== START FILE: backend\alembic\env.py =====
from __future__ import annotations
import os
from logging.config import fileConfig
from pathlib import Path

from sqlalchemy import engine_from_config, pool
from alembic import context

# Load .env (../.. from this file)
ENV_PATH = Path(__file__).resolve().parents[2] / ".env"
if ENV_PATH.exists():
    try:
        from dotenv import load_dotenv
        load_dotenv(ENV_PATH)
    except Exception:
        pass

config = context.config

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

from backend.db import Base  # exposes Base.metadata

target_metadata = Base.metadata

def run_migrations_offline() -> None:
    url = os.getenv("DATABASE_URL") or config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        compare_type=True,
        compare_server_default=True,
    )
    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online() -> None:
    database_url = os.getenv("DATABASE_URL")
    if database_url:
        config.set_main_option("sqlalchemy.url", database_url)

    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
        future=True,
    )
    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
            compare_type=True,
            compare_server_default=True,
        )
        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

===== END FILE: backend\alembic\env.py =====


===== START FILE: backend\alembic\versions\3621eccb87cd_ensure_tiers_user_fk.py =====
"""ensure tiers + user FK

Revision ID: 3621eccb87cd
Revises: e9913c4d39f7
Create Date: 2025-09-28 13:44:30.063376

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '3621eccb87cd'
down_revision: Union[str, None] = 'e9913c4d39f7'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###

===== END FILE: backend\alembic\versions\3621eccb87cd_ensure_tiers_user_fk.py =====


===== START FILE: backend\alembic\versions\e9913c4d39f7_baseline_all_models.py =====
"""baseline all models

Revision ID: e9913c4d39f7
Revises: 
Create Date: 2025-09-28 13:09:01.797574

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'e9913c4d39f7'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###

===== END FILE: backend\alembic\versions\e9913c4d39f7_baseline_all_models.py =====


===== START FILE: backend\alembic_old\env.py =====
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context
from backend.db import Base, engine
from backend import models  # Import all models so Alembic detects them

config = context.config
fileConfig(config.config_file_name)
target_metadata = Base.metadata

def run_migrations_offline():
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online():
    connectable = engine
    with connectable.connect() as connection:
        context.configure(connection=connection, target_metadata=target_metadata)
        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

===== END FILE: backend\alembic_old\env.py =====


===== START FILE: backend\alembic_old_20250928_130527\env.py =====
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = None

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

===== END FILE: backend\alembic_old_20250928_130527\env.py =====


===== START FILE: backend\alembic_old_20250928_130545\env.py =====
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = None

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

===== END FILE: backend\alembic_old_20250928_130545\env.py =====


===== START FILE: backend\app\__init__.py =====
===== END FILE: backend\app\__init__.py =====


===== START FILE: backend\app\bind_routes.py =====
from fastapi import FastAPI
from backend.routes import (
    # Phase 1 – Core
    health_routes,

    # Phase 2 – Users & Auth
    user_routes,

    # Phase 3 – Toggles & System Flags
    toggle_routes,

    # Phase 4 – Tiers & Monetization
    premium_routes,

    # Phase 5 – Core Generation (Image, Video, Upload, LoRA, Avatar)
    lora_routes,
    avatar_routes,
    upload_routes,
    media_routes,
    video_routes,

    # Phase 6 – Whisper Integration
    whisper_routes,

    # Phase 7 – History, Metrics, Analytics
    history_routes,
    metrics_routes,
    analytics_routes,

    # Phase 8 – Community & Social
    community_routes,
    lounge_routes,
    post_routes,
    comment_routes,
    reaction_routes,
    invite_routes,
    motion_routes,
)

def bind_routes(app: FastAPI) -> None:
    # Phase 1
    app.include_router(health_routes.router, prefix="/health", tags=["health"])

    # Phase 2
    app.include_router(user_routes.router, prefix="/user", tags=["user"])

    # Phase 3
    app.include_router(toggle_routes.router, prefix="/toggle", tags=["toggle"])

    # Phase 4
    app.include_router(premium_routes.router, prefix="/premium", tags=["premium"])

    # Phase 5
    app.include_router(lora_routes.router, prefix="/lora", tags=["lora"])
    app.include_router(avatar_routes.router, prefix="/avatar", tags=["avatar"])
    app.include_router(upload_routes.router, prefix="/upload", tags=["upload"])
    app.include_router(media_routes.router, prefix="/media", tags=["media"])
    app.include_router(video_routes.router, prefix="/video", tags=["video"])

    # Phase 6
    app.include_router(whisper_routes.router, prefix="/whisper", tags=["whisper"])

    # Phase 7
    app.include_router(history_routes.router, prefix="/history", tags=["history"])
    app.include_router(metrics_routes.router, prefix="/metrics", tags=["metrics"])
    app.include_router(analytics_routes.router, prefix="/analytics", tags=["analytics"])

    # Phase 8
    app.include_router(community_routes.router, prefix="/community", tags=["community"])
    app.include_router(lounge_routes.router, prefix="/lounge", tags=["lounge"])
    app.include_router(post_routes.router, prefix="/post", tags=["post"])
    app.include_router(comment_routes.router, prefix="/comment", tags=["comment"])
    app.include_router(reaction_routes.router, prefix="/reaction", tags=["reaction"])
    app.include_router(invite_routes.router, prefix="/invite", tags=["invite"])
    app.include_router(motion_routes.router, prefix="/motion", tags=["motion"])
# Phase 9 router includes
try:
    from backend.routes.moderation_routes import moderation_router
    from backend.routes.report_routes import report_router
    app.include_router(moderation_router)
    app.include_router(report_router)
except Exception as _e:
    # Safe no-op if already included or during import order issues
    pass
# Phase 9 router includes
try:
    from backend.routes.moderation_routes import moderation_router
    from backend.routes.report_routes import report_router
    app.include_router(moderation_router)
    app.include_router(report_router)
except Exception as _e:
    # Safe no-op if already included
    pass

===== END FILE: backend\app\bind_routes.py =====


===== START FILE: backend\app\cors.py =====
def get_cors_config():
    """
    Centralized CORS configuration.
    """
    return {
        "allow_origins": ["*"],  # TODO: tighten in production
        "allow_credentials": True,
        "allow_methods": ["*"],
        "allow_headers": ["*"],
    }

===== END FILE: backend\app\cors.py =====


===== START FILE: backend\app\create_app.py =====
from fastapi import FastAPI
from backend.routes import whisper_routes

def create_app():
    app = FastAPI()
    app.include_router(whisper_routes.router)
        from backend.app.routers_phase9 import include_phase9
    include_phase9(app)
    return app
# === Phase 10 router includes (auto) ===
try:
    from backend.app.routers_phase10 import include_phase10
    include_phase10(app)
except Exception:
    pass

===== END FILE: backend\app\create_app.py =====


===== START FILE: backend\app\error_handlers.py =====
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException

def register_error_handlers(app: FastAPI) -> None:
    """
    Attach global exception handlers.
    """

    @app.exception_handler(StarletteHTTPException)
    async def http_exception_handler(request: Request, exc: StarletteHTTPException):
        return JSONResponse(
            status_code=exc.status_code,
            content={"detail": exc.detail, "status_code": exc.status_code},
        )

    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        return JSONResponse(
            status_code=422,
            content={"detail": exc.errors(), "body": exc.body},
        )

    @app.exception_handler(Exception)
    async def generic_exception_handler(request: Request, exc: Exception):
        return JSONResponse(
            status_code=500,
            content={"detail": str(exc), "status_code": 500},
        )

===== END FILE: backend\app\error_handlers.py =====


===== START FILE: backend\app\events.py =====
from fastapi import FastAPI
from backend.db import engine
from backend.models import base

def register_events(app: FastAPI) -> None:
    """
    Application lifecycle events: startup/shutdown hooks.
    """

    @app.on_event("startup")
    async def on_startup():
        # Create all tables on startup (only for dev / SQLite).
        base.Base.metadata.create_all(bind=engine)
        print("?? Application startup complete, database ready.")

    @app.on_event("shutdown")
    async def on_shutdown():
        print("?? Application shutdown.")

===== END FILE: backend\app\events.py =====


===== START FILE: backend\app\logger.py =====
import logging

def init_logger() -> logging.Logger:
    """
    Configure global logger for the application.
    """
    logger = logging.getLogger("whisper_laced")
    logger.setLevel(logging.INFO)

    # Prevent duplicate handlers if logger is re-initialized
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)

    return logger

===== END FILE: backend\app\logger.py =====


===== START FILE: backend\app\main.py =====
from backend.routes.files_routes import router as files_router
from backend.routes.metrics_routes import router as metrics_router
from backend.middleware.rate_limit import RateLimitMiddleware
from backend.routes.generate_routes import router as generate_router
from fastapi.staticfiles import StaticFiles
from backend.config import settings
from backend.routes import auth_routes
import os, sys
from pathlib import Path

# Path shim
ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

# Load .env
try:
    from dotenv import load_dotenv
    load_dotenv(Path(ROOT) / ".env")
except Exception:
    pass

from fastapi import FastAPI

# Import ALL models so Base.metadata sees tables (no forced mapper config)
import backend.models  # dynamically imports all model modules

from backend.db import Base, engine
from backend.routes import user_routes
from backend.routes import whisper_routes

app = FastAPI(title="Laced API")



app.include_router(auth_routes.router)
from backend.app.routers_phase9 import include_phase9
include_phase9(app)
# Dev convenience; safe if Alembic already ran
Base.metadata.create_all(bind=engine)

# Global DEV auth bypass (only used if .env sets DEV_NO_AUTH=1)
DEV_NO_AUTH = os.getenv("DEV_NO_AUTH", "0") == "1"
if DEV_NO_AUTH:
    try:
        from backend.core import auth
        class _DevUser: id = 1
        app.dependency_overrides[auth.get_current_user] = lambda: _DevUser()
        print("[DEV] Auth bypass ENABLED (get_current_user overridden)")
    except Exception as e:
        print("[DEV] Bypass failed:", e)

# Routers
app.include_router(user_routes.router)
app.include_router(whisper_routes.router)

@app.get("/health")
def health():
    return {"ok": True, "dev_no_auth": DEV_NO_AUTH}

# === Phase 10 router includes (auto) ===
try:
    from backend.app.routers_phase10 import include_phase10
    include_phase10(app)
except Exception:
    pass


# === Phase11 middleware (idempotent manual insert) ===
from backend.middleware.request_id import RequestIDMiddleware
from backend.middleware.logging_mw import AccessLoggingMiddleware
from backend.middleware.rate_limit_mw import RateLimitMiddleware
from backend.middleware.timeout_mw import TimeoutMiddleware
from backend.middleware.session_mw import SessionMiddlewareLite

try:
    app.add_middleware(RequestIDMiddleware)
    app.add_middleware(AccessLoggingMiddleware)
    app.add_middleware(RateLimitMiddleware)
    app.add_middleware(TimeoutMiddleware)
    app.add_middleware(SessionMiddlewareLite)
except Exception:
    # app may not be defined yet depending on your structure; manually place these after app = FastAPI()
    pass
# === end Phase11 ===



app.include_router(metrics_router)
app.mount("/files", StaticFiles(directory=settings.OUTPUT_DIR), name="files")

app.include_router(generate_router)

===== END FILE: backend\app\main.py =====


===== START FILE: backend\app\route_registration_patch.py =====
from backend.routes import (
    post_routes,
    comment_routes,
    reaction_routes,
    invite_routes,
    community_routes,
    lounge_routes,
    motion_routes,
)

app.include_router(post_routes.router, prefix="/post", tags=["Post"])
app.include_router(comment_routes.router, prefix="/comment", tags=["Comment"])
app.include_router(reaction_routes.router, prefix="/reaction", tags=["Reaction"])
app.include_router(invite_routes.router, prefix="/invite", tags=["Invite"])
app.include_router(community_routes.router, prefix="/community", tags=["Community"])
app.include_router(lounge_routes.router, prefix="/lounge", tags=["Lounge"])
app.include_router(motion_routes.router, prefix="/motion", tags=["Motion"])

===== END FILE: backend\app\route_registration_patch.py =====


===== START FILE: backend\app\routers_phase10.py =====
from __future__ import annotations
def include_phase10(app):
    from backend.controllers.editor_controller import router as editor_router
    from backend.controllers.enhancement_request_controller import router as enhancement_router
    app.include_router(editor_router)
    app.include_router(enhancement_router)

===== END FILE: backend\app\routers_phase10.py =====


===== START FILE: backend\app\routers_phase9.py =====
from fastapi import APIRouter
from backend.controllers.moderation_controller import router as moderation_router
from backend.controllers.report_controller import router as report_router
from backend.controllers.editor_controller import router as editor_router
try:
    from backend.controllers.enhancement_request_controller import router as enhancement_router
except ImportError:
    from backend.controllers.enhancement_controller import router as enhancement_router
from backend.controllers.auth_controller import router as auth_router
from backend.controllers.auth_token_controller import router as auth_token_router

def include_phase9(app):
    app.include_router(moderation_router)
    app.include_router(report_router)
    app.include_router(editor_router)
    app.include_router(enhancement_router)
    app.include_router(auth_router)        # /auth/me
    app.include_router(auth_token_router)  # /auth/token

    probe = APIRouter()
    @probe.get("/editor/ping")
    def ping_probe():
        return {"ok": True, "source": "routers_phase9"}
    app.include_router(probe)

===== END FILE: backend\app\routers_phase9.py =====


===== START FILE: backend\celery_app.py =====
from __future__ import annotations
from celery import Celery
from backend.config import settings

def make_celery() -> Celery:
    app = Celery(
        "backend",
        broker=settings.CELERY_BROKER_URL,
        backend=settings.CELERY_RESULT_BACKEND,
        include=[
            "backend.tasks.generate",
            "backend.tasks.notifications",
            "backend.tasks.moderation_tasks",
        ],
    )
    app.conf.update(
        imports=("backend.tasks.generate",),
        task_serializer="json",
        accept_content=["json"],
        result_serializer="json",
        timezone="UTC",
        enable_utc=True,
    )
    return app

app: Celery = make_celery()
celery: Celery = app
__all__ = ["app", "celery"]
===== END FILE: backend\celery_app.py =====


===== START FILE: backend\config.py =====
from __future__ import annotations
import os
from pydantic import BaseModel

class Settings(BaseModel):
    # Celery broker/backend
    CELERY_BROKER_URL: str = os.getenv("CELERY_BROKER_URL", "redis://127.0.0.1:6379/0")
    CELERY_RESULT_BACKEND: str = os.getenv("CELERY_RESULT_BACKEND", "redis://127.0.0.1:6379/1")

    # Output dir for generated artifacts
    OUTPUT_DIR: str = os.getenv("LACED_OUTPUT_DIR", r"D:\whisper-laced\outputs\images")

    # Generation mode: "http" or "local"
    GENERATOR_MODE: str = os.getenv("GENERATOR_MODE", "http")

    # HTTP generator settings (used if GENERATOR_MODE=http)
    GENERATOR_HTTP_URL: str = os.getenv("GENERATOR_HTTP_URL", "http://127.0.0.1:8188/generate")
    GENERATOR_HTTP_TIMEOUT: float = float(os.getenv("GENERATOR_HTTP_TIMEOUT", "120"))

    # Security / misc
    SECRET_KEY: str = os.getenv("SECRET_KEY", "CHANGE_ME")
    ALLOW_ORIGINS: str = os.getenv("ALLOW_ORIGINS", "*")  # CORS

settings = Settings()
===== END FILE: backend\config.py =====


===== START FILE: backend\controllers\__init__.py =====


===== END FILE: backend\controllers\__init__.py =====


===== START FILE: backend\controllers\auth_controller.py =====
from typing import Any, Dict
from fastapi import APIRouter, Depends

# relaxed dependency: never raises, returns claims dict or {"token":"unverified"}
from backend.dependencies.auth_relaxed import get_current_user

router = APIRouter(prefix="/auth", tags=["auth"])

@router.get("/me")
def me(claims: Dict[str, Any] = Depends(get_current_user)) -> Dict[str, Any]:
    """
    Returns token claims if available, otherwise {"token":"unverified"}.
    Keeps shape stable for callers that expect sub/email/is_admin/exp.
    """
    if isinstance(claims, dict) and claims.get("token") == "unverified":
        return {"token": "unverified"}

    sub = (claims or {}).get("sub")
    email = (claims or {}).get("email")
    is_admin = bool((claims or {}).get("is_admin", False))
    exp = (claims or {}).get("exp")

    return {
        "sub": sub,
        "email": email,
        "is_admin": is_admin,
        "exp": exp,
    }

__all__ = ["router"]

===== END FILE: backend\controllers\auth_controller.py =====


===== START FILE: backend\controllers\auth_diag_controller.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from sqlalchemy import select
from backend.db import engine, get_db
from backend.core.config import settings
from backend.models.user import User
from backend.core.password import verify_password

router = APIRouter(prefix="/auth", tags=["auth"])

@router.get("/diag")
def auth_diag(db: Session = Depends(get_db)):
    email = "whisperandlaced@gmail.com"
    row = db.execute(select(User).where(User.email==email)).scalar_one_or_none()
    ok = False
    if row and row.hashed_password:
        ok = verify_password("AandD03022022$", row.hashed_password)
    return {
        "settings_db": settings.DATABASE_URL,
        "engine_url": str(engine.url),
        "user_found": bool(row),
        "verify_ok": ok,
    }

===== END FILE: backend\controllers\auth_diag_controller.py =====


===== START FILE: backend\controllers\auth_echo_controller.py =====
from backend.core.password import verify_password


from __future__ import annotations
from fastapi import APIRouter, Request
router = APIRouter(prefix="/__auth_diag", tags=["__auth_diag"])
@router.get("/echo")
def echo(req: Request):
    return {"authorization": req.headers.get("authorization")}





===== END FILE: backend\controllers\auth_echo_controller.py =====


===== START FILE: backend\controllers\auth_token_controller.py =====
from __future__ import annotations
from datetime import datetime, timedelta
from typing import Optional
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from jose import jwt
from sqlalchemy.orm import Session

from backend.db import get_db
from backend.core.config import settings
from backend.services.auth_service import authenticate_user

router = APIRouter(prefix="/auth", tags=["auth"])

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.JWT_ALGORITHM)

@router.post("/token")
def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db),
):
    user = authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    token = create_access_token({"sub": str(user.id), "email": user.email, "is_admin": False})
    return {"access_token": token, "token_type": "bearer"}

===== END FILE: backend\controllers\auth_token_controller.py =====


===== START FILE: backend\controllers\auth_token_debug_controller.py =====
from backend.core.password import verify_password


from __future__ import annotations
import os, sys, datetime as dt
from typing import Optional, Any
from fastapi import APIRouter, Depends, HTTPException, Body
from sqlalchemy.orm import Session

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

from backend.db import get_db

router = APIRouter(prefix="/auth", tags=["auth-debug"])

def _get_hasher():
    try:
        from passlib.hash import bcrypt as pl_bcrypt
        def verify(plain: str, hashed: str) -> bool:
            try: return pl_bcrypt.verify(plain, hashed)
            except Exception: return False
        return verify
    except Exception:
        pass
    try:
        def verify(plain: str, hashed: str) -> bool:
            try: return bcrypt.checkpw(plain.encode("utf-8"), hashed.encode("utf-8"))
            except Exception: return False
        return verify
    except Exception:
        pass
    return lambda p,h: False

VERIFY = _get_hasher()

def _find_user_by_email(db: Session, email: str) -> Optional[Any]:
    try:
        from backend.models.user import User
        return db.query(User).filter(User.email == email).first()
    except Exception:
        return None

def _user_password_hash(user: Any) -> Optional[str]:
    for field in ("hashed_password","password_hash","password"):
        if hasattr(user, field):
            v = getattr(user, field)
            if isinstance(v, str) and v:
                return v
    return None

def _create_token(claims: dict) -> str:
    try:
        from backend.core import auth
        if hasattr(auth, "create_access_token"):
            return auth.create_access_token(claims)
    except Exception:
        pass
    secret = os.getenv("SECRET_KEY", "dev-secret-change-me")
    alg = os.getenv("ALGORITHM", "HS256")
    exp_minutes = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "60"))
    payload = claims.copy()
    payload["exp"] = dt.datetime.utcnow() + dt.timedelta(minutes=exp_minutes)
    try:
        from jose import jwt as jose_jwt
        return jose_jwt.encode(payload, secret, algorithm=alg)
    except Exception:
        import jwt as pyjwt
        return pyjwt.encode(payload, secret, algorithm=alg)

@router.post("/token_debug")
def token_debug(payload: dict = Body(...), db: Session = Depends(get_db)):
    # expects {"email": "...", "password": "..."}
    email = payload.get("email")
    password = payload.get("password")
    if not email or not password:
        raise HTTPException(status_code=400, detail="email and password required")

    user = _find_user_by_email(db, email)
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect username or password")

    hashed = _user_password_hash(user)
    if not hashed or not VERIFY(password, hashed):
        raise HTTPException(status_code=400, detail="Incorrect username or password")

    claims = {"sub": str(getattr(user, "id", "")), "email": getattr(user, "email", None)}
    token = _create_token(claims)
    return {"access_token": token, "token_type": "bearer"}





===== END FILE: backend\controllers\auth_token_debug_controller.py =====


===== START FILE: backend\controllers\ban.py =====
from fastapi import APIRouter, Depends, HTTPException, status
# ban.py
router = APIRouter()
@router.post("/ban") 
def ban_user(): pass

===== END FILE: backend\controllers\ban.py =====


===== START FILE: backend\controllers\billing.py =====
from fastapi import APIRouter
# billing.py
router = APIRouter()
@router.post("/billing")
def handle_billing(): pass

===== END FILE: backend\controllers\billing.py =====


===== START FILE: backend\controllers\cache.py =====
from fastapi import APIRouter
# cache.py
router = APIRouter()
@router.get("/cache/clear")
def clear_cache(): pass

===== END FILE: backend\controllers\cache.py =====


===== START FILE: backend\controllers\collection.py =====
from fastapi import APIRouter
# collection.py
router = APIRouter()
@router.get("/collections")
def list_collections(): pass

===== END FILE: backend\controllers\collection.py =====


===== START FILE: backend\controllers\comment.py =====
from fastapi import APIRouter
# comment.py
router = APIRouter()
@router.post("/comments")
def post_comment(): pass

===== END FILE: backend\controllers\comment.py =====


===== START FILE: backend\controllers\community.py =====
from fastapi import APIRouter
# community.py
router = APIRouter()
@router.get("/community")
def get_community(): pass

===== END FILE: backend\controllers\community.py =====


===== START FILE: backend\controllers\dev_debug_controller.py =====
from __future__ import annotations
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from typing import Optional

from backend.db import get_db
from backend.services import moderation_service, report_service
from backend.models.moderation import ModerationStatus, TargetType
from backend.models.report import ReportStatus

router = APIRouter(prefix="/__dev_phase9", tags=["__dev_phase9"])

@router.get("/moderation")
def dev_list_moderation(
    db: Session = Depends(get_db),
    status: Optional[ModerationStatus] = Query(None),
    target_type: Optional[TargetType] = Query(None),
    assignee_id: Optional[int] = Query(None),
    limit: int = Query(10, ge=1, le=100),
    offset: int = Query(0, ge=0),
):
    items, total = moderation_service.list_cases(db, status=status, target_type=target_type, assignee_id=assignee_id, limit=limit, offset=offset)
    return {"total": total, "items": [ {"id": c.id, "status": c.status, "target_type": c.target_type, "target_id": c.target_id, "is_nsfw": c.is_nsfw } for c in items ]}

@router.get("/reports")
def dev_list_reports(
    db: Session = Depends(get_db),
    status: Optional[ReportStatus] = Query(None),
    target_type: Optional[TargetType] = Query(None),
    limit: int = Query(10, ge=1, le=100),
    offset: int = Query(0, ge=0),
):
    items, total = report_service.list_reports(db, status=status, target_type=target_type, limit=limit, offset=offset)
    return {"total": total, "items": [ {"id": r.id, "status": r.status, "reason": r.reason, "target_type": r.target_type, "target_id": r.target_id } for r in items ]}

===== END FILE: backend\controllers\dev_debug_controller.py =====


===== START FILE: backend\controllers\editor.py =====
from fastapi import APIRouter
# editor.py
router = APIRouter()
@router.post("/editor/save")
def save_edit(): pass

===== END FILE: backend\controllers\editor.py =====


===== START FILE: backend\controllers\editor_controller.py =====
from typing import Any, Dict, List
from fastapi import APIRouter, HTTPException
import os, sqlite3

router = APIRouter(prefix="/editor", tags=["editor"])

# ---------- DB helpers ----------
def _db_path() -> str:
    url = os.getenv("DATABASE_URL", "").strip()
    if url.startswith("sqlite:///"):
        return os.path.normpath(url[len("sqlite:///"):])
    return os.path.normpath(r"D:/whisper-laced/backend/db.sqlite3")

def _open():
    p = _db_path()
    os.makedirs(os.path.dirname(p), exist_ok=True)
    con = sqlite3.connect(p)
    con.row_factory = sqlite3.Row
    return con

def _ensure_schema(con: sqlite3.Connection):
    cur = con.cursor()
    # editor_documents
    cur.execute("""CREATE TABLE IF NOT EXISTS editor_documents(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        created_at TEXT DEFAULT (datetime('now'))
    );""")
    # editor_versions
    cur.execute("""CREATE TABLE IF NOT EXISTS editor_versions(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        doc_id INTEGER NOT NULL,
        version INTEGER NOT NULL,
        body TEXT NOT NULL,
        created_at TEXT DEFAULT (datetime('now')),
        UNIQUE(doc_id, version)
    );""")
    con.commit()

# ---------- routes ----------
@router.get("/ping")
def ping():
    return {"ok": True, "router": "editor", "db": _db_path()}

@router.post("/documents")
def create_document(body: Dict[str, Any]) -> Dict[str, Any]:
    title = (body or {}).get("title")
    text  = (body or {}).get("body")
    if not title or not text:
        raise HTTPException(422, "title and body are required")
    con = _open()
    try:
        _ensure_schema(con)
        cur = con.cursor()
        cur.execute("INSERT INTO editor_documents(title) VALUES(?)", (title,))
        doc_id = cur.lastrowid
        # v1
        cur.execute("INSERT INTO editor_versions(doc_id, version, body) VALUES(?,?,?)",
                    (doc_id, 1, text))
        con.commit()
        return {"id": doc_id, "title": title, "body": text, "version": 1}
    finally:
        con.close()

@router.get("/documents/{doc_id}")
def read_document(doc_id: int) -> Dict[str, Any]:
    con = _open()
    try:
        _ensure_schema(con)
        cur = con.cursor()
        cur.execute("SELECT id, title, created_at FROM editor_documents WHERE id=?", (doc_id,))
        doc = cur.fetchone()
        if not doc:
            raise HTTPException(404, "document not found")
        cur.execute("""SELECT version, body, created_at
                       FROM editor_versions
                       WHERE doc_id=? ORDER BY version DESC LIMIT 1""", (doc_id,))
        ver = cur.fetchone()
        if not ver:
            raise HTTPException(500, "document has no versions")
        return {
            "id": doc["id"], "title": doc["title"], "created_at": doc["created_at"],
            "version": ver["version"], "body": ver["body"], "version_created_at": ver["created_at"],
        }
    finally:
        con.close()

@router.get("/documents/{doc_id}/versions")
def list_versions(doc_id: int) -> List[Dict[str, Any]]:
    con = _open()
    try:
        _ensure_schema(con)
        cur = con.cursor()
        cur.execute("""SELECT version, body, created_at
                       FROM editor_versions
                       WHERE doc_id=? ORDER BY version ASC""", (doc_id,))
        return [dict(r) for r in cur.fetchall()]
    finally:
        con.close()

@router.post("/documents/{doc_id}/enhance")
def enhance_document(doc_id: int, body: Dict[str, Any]) -> Dict[str, Any]:
    instruction = (body or {}).get("instruction")
    if not instruction:
        raise HTTPException(422, "instruction is required")
    con = _open()
    try:
        _ensure_schema(con)
        cur = con.cursor()
        # get latest version + body
        cur.execute("""SELECT version, body FROM editor_versions
                       WHERE doc_id=? ORDER BY version DESC LIMIT 1""", (doc_id,))
        last = cur.fetchone()
        if not last:
            raise HTTPException(404, "document not found")
        last_v = int(last["version"])
        last_body = last["body"]
        # naive “enhancement”: trim + ensure final punctuation (placeholder)
        new_body = (last_body or "").strip()
        if new_body and new_body[-1] not in ".!?":
            new_body = new_body + "."
        new_v = last_v + 1
        cur.execute("INSERT INTO editor_versions(doc_id, version, body) VALUES(?,?,?)",
                    (doc_id, new_v, new_body))
        # also log enhancement in enhancement_requests if that table exists
        cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='enhancement_requests'")
        if cur.fetchone():
            cur.execute("""INSERT INTO enhancement_requests(doc_id, instruction)
                           VALUES(?,?)""", (doc_id, instruction))
        con.commit()
        return {"doc_id": doc_id, "version": new_v, "body": new_body, "instruction": instruction}
    finally:
        con.close()

===== END FILE: backend\controllers\editor_controller.py =====


===== START FILE: backend\controllers\enhancement_controller.py =====
from typing import Any, Dict, List
from fastapi import APIRouter
import os, sqlite3

router = APIRouter(prefix="/enhancements", tags=["enhancements"])

def _db_path() -> str:
    url = os.getenv("DATABASE_URL", "").strip()
    if url.startswith("sqlite:///"):
        return os.path.normpath(url[len("sqlite:///"):])
    return os.path.normpath(r"D:/whisper-laced/backend/db.sqlite3")

def _open():
    p = _db_path()
    os.makedirs(os.path.dirname(p), exist_ok=True)
    con = sqlite3.connect(p)
    con.row_factory = sqlite3.Row
    return con

@router.get("/")
def list_enhancements() -> List[Dict[str, Any]]:
    con = _open()
    try:
        cur = con.cursor()
        cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='enhancements'")
        if not cur.fetchone():
            return []
        cur.execute("SELECT id, doc_id, instruction, created_at FROM enhancements ORDER BY id DESC LIMIT 100")
        return [dict(r) for r in cur.fetchall()]
    finally:
        con.close()

===== END FILE: backend\controllers\enhancement_controller.py =====


===== START FILE: backend\controllers\enhancement_request.py =====
from fastapi import APIRouter
# enhancement_request.py
router = APIRouter()
@router.post("/enhancements")
def request_enhancement(): pass

===== END FILE: backend\controllers\enhancement_request.py =====


===== START FILE: backend\controllers\enhancement_request_controller.py =====
from typing import Any, Dict, List
from fastapi import APIRouter
import os, sqlite3

router = APIRouter(prefix="/enhancements", tags=["enhancements"])

def _db_path() -> str:
    url = os.getenv("DATABASE_URL", "").strip()
    if url.startswith("sqlite:///"):
        return os.path.normpath(url[len("sqlite:///"):])
    return os.path.normpath(r"D:/whisper-laced/backend/db.sqlite3")

def _open():
    p = _db_path()
    os.makedirs(os.path.dirname(p), exist_ok=True)
    con = sqlite3.connect(p)
    con.row_factory = sqlite3.Row
    return con

def _ensure_schema(con: sqlite3.Connection):
    cur = con.cursor()
    cur.execute("""CREATE TABLE IF NOT EXISTS enhancement_requests(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        doc_id INTEGER NOT NULL,
        instruction TEXT NOT NULL,
        created_at TEXT DEFAULT (datetime('now'))
    );""")
    con.commit()

@router.get("/")
def list_enhancements() -> List[Dict[str, Any]]:
    con = _open()
    try:
        _ensure_schema(con)
        cur = con.cursor()
        cur.execute("""SELECT id, doc_id, instruction, created_at
                       FROM enhancement_requests
                       ORDER BY id DESC LIMIT 100""")
        return [dict(r) for r in cur.fetchall()]
    finally:
        con.close()

===== END FILE: backend\controllers\enhancement_request_controller.py =====


===== START FILE: backend\controllers\export.py =====
from fastapi import APIRouter
# export.py
router = APIRouter()
@router.get("/export")
def export_data(): pass

===== END FILE: backend\controllers\export.py =====


===== START FILE: backend\controllers\feature.py =====
from fastapi import APIRouter
# feature.py
router = APIRouter()
@router.get("/features")
def list_features(): pass

===== END FILE: backend\controllers\feature.py =====


===== START FILE: backend\controllers\lora.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import List
from backend.db import get_db
from backend.schemas.lora_schema import LoRACreate, LoRAResponse
from backend.services import lora_service
from backend.dependencies.auth import get_current_user

router = APIRouter()

@router.post("/", response_model=LoRAResponse)
def upload_lora(lora: LoRACreate, db: Session = Depends(get_db), current_user=Depends(get_current_user)):
    return lora_service.create_lora(db, lora, current_user.id)

@router.get("/", response_model=List[LoRAResponse])
def list_loras(db: Session = Depends(get_db), current_user=Depends(get_current_user)):
    return lora_service.list_loras(db)

===== END FILE: backend\controllers\lora.py =====


===== START FILE: backend\controllers\moderation_controller.py =====
from __future__ import annotations
from typing import Optional
from fastapi import APIRouter, Depends, Query, HTTPException

# tolerate missing roles module (dev mode); in prod we use real guard
def _noop(dep=None):
    def _inner(*args, **kwargs):
        return None
    return _inner

try:
    from backend.dependencies.roles import require_admin_or_moderator
except Exception:
    require_admin_or_moderator = _noop()

router = APIRouter(prefix="/moderation", tags=["moderation"])

@router.get("/", dependencies=[Depends(require_admin_or_moderator)])
def list_cases(limit: int = Query(20, ge=1, le=200), offset: int = Query(0, ge=0)):
    # wire-up stub: return empty list for now
    return []

@router.get("/{case_id}", dependencies=[Depends(require_admin_or_moderator)])
def get_case(case_id: int):
    # stub detail
    return {"id": case_id, "status": "open"}

@router.post("/{case_id}/assign", dependencies=[Depends(require_admin_or_moderator)])
def assign_case(case_id: int, assignee: Optional[int] = None):
    return {"id": case_id, "assigned_to": assignee}

@router.post("/{case_id}/status", dependencies=[Depends(require_admin_or_moderator)])
def update_status(case_id: int, status: str = Query(..., pattern="^(open|closed|review)$")):
    return {"id": case_id, "status": status}

===== END FILE: backend\controllers\moderation_controller.py =====


===== START FILE: backend\controllers\premium_controller.py =====
from fastapi import Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from backend.db import get_db
from backend.schemas.tier_schema import TierCreate, TierUpdate, TierResponse
from backend.schemas.user_schema import UserResponse
from backend.services import premium_service
from backend.dependencies.roles import require_role

def create_tier(tier: TierCreate, db: Session = Depends(get_db)) -> TierResponse:
    return premium_service.create_tier(db, tier)

def list_tiers(db: Session = Depends(get_db)) -> List[TierResponse]:
    return premium_service.list_tiers(db)

def update_tier(tier_id: int, tier: TierUpdate, db: Session = Depends(get_db)) -> TierResponse:
    db_tier = premium_service.update_tier(db, tier_id, tier)
    if not db_tier:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Tier not found")
    return db_tier

def delete_tier(tier_id: int, db: Session = Depends(get_db)) -> dict:
    success = premium_service.delete_tier(db, tier_id)
    if not success:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Tier not found")
    return {"detail": "Tier deleted"}

def assign_user(user_id: int, tier_id: int, db: Session = Depends(get_db)) -> UserResponse:
    user = premium_service.assign_user_to_tier(db, user_id, tier_id)
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User or Tier not found")
    return user

===== END FILE: backend\controllers\premium_controller.py =====


===== START FILE: backend\controllers\report_controller.py =====
from typing import Any, Dict, List, Optional
from fastapi import APIRouter, HTTPException, Query, Request
import os, sqlite3

# Try to use PyJWT if present to read sub from token
try:
    import jwt  # PyJWT
except Exception:
    jwt = None

router = APIRouter(prefix="/reports", tags=["reports"])

def _db_path() -> str:
    url = os.getenv("DATABASE_URL", "").strip()
    if url.startswith("sqlite:///"):
        path = url[len("sqlite:///"):]
        return os.path.normpath(path)
    return os.path.normpath(r"D:/whisper-laced/backend/db.sqlite3")

def _open():
    path = _db_path()
    os.makedirs(os.path.dirname(path), exist_ok=True)
    con = sqlite3.connect(path, timeout=10)
    con.row_factory = sqlite3.Row
    return con

def _user_id_from_token(request: Request) -> int:
    # Best effort parse of "Authorization: Bearer <jwt>"
    auth = request.headers.get("authorization") or request.headers.get("Authorization")
    if not auth or " " not in auth:
        return 1
    scheme, token = auth.split(" ", 1)
    if scheme.lower() != "bearer":
        return 1
    secret = os.getenv("SECRET_KEY", "")
    if not jwt or not secret:
        return 1
    try:
        claims = jwt.decode(token, secret, algorithms=["HS256"])
        sub = claims.get("sub")
        return int(sub) if sub is not None else 1
    except Exception:
        return 1

@router.get("/", response_model=List[Dict[str, Any]])
def list_reports(limit: int = Query(50, ge=1, le=200), offset: int = Query(0, ge=0)):
    con = _open()
    try:
        cur = con.cursor()
        # Use the actual columns present in your DB
        cur.execute(
            "SELECT id, reporter_id, target_type, target_id, reason, details, "
            "status, moderation_case_id, created_at, updated_at, ref_id, topic "
            "FROM reports ORDER BY id DESC LIMIT ? OFFSET ?",
            (limit, offset)
        )
        return [dict(r) for r in cur.fetchall()]
    finally:
        con.close()

@router.post("/", response_model=Dict[str, Any])
def create_report(request: Request, body: Dict[str, Any]):
    # REQUIRED by your schema
    for k in ("reason", "target_type", "target_id"):
        if k not in body:
            raise HTTPException(422, f"Missing field: {k}")

    reporter_id = _user_id_from_token(request)
    reason: str = str(body["reason"])
    target_type: str = str(body["target_type"])
    try:
        target_id: int = int(body["target_id"])
    except Exception:
        raise HTTPException(422, "target_id must be an integer")

    # Optional fields your table also has
    topic: Optional[str] = body.get("topic")
    ref_id: Optional[int] = body.get("ref_id")
    details: Optional[str] = body.get("details")

    con = _open()
    try:
        cur = con.cursor()
        try:
            cur.execute(
                "INSERT INTO reports (reporter_id, target_type, target_id, reason, details, status, created_at, updated_at, ref_id, topic) "
                "VALUES (?,?,?,?,?,'open',datetime('now'),datetime('now'),?,?)",
                (reporter_id, target_type, target_id, reason, details, ref_id, topic)
            )
            rid = cur.lastrowid
            con.commit()
        except Exception as e:
            raise HTTPException(500, f"insert_failed: {type(e).__name__}: {e}")
        cur.execute(
            "SELECT id, reporter_id, target_type, target_id, reason, details, status, moderation_case_id, created_at, updated_at, ref_id, topic "
            "FROM reports WHERE id=?",
            (rid,)
        )
        row = cur.fetchone()
        return dict(row)
    finally:
        con.close()

@router.post("/{report_id}/close", response_model=Dict[str, Any])
def close_report(report_id: int):
    con = _open()
    try:
        cur = con.cursor()
        cur.execute(
            "UPDATE reports SET status='closed', updated_at=datetime('now') WHERE id=?",
            (report_id,)
        )
        con.commit()
        cur.execute(
            "SELECT id, reporter_id, target_type, target_id, reason, details, status, moderation_case_id, created_at, updated_at, ref_id, topic "
            "FROM reports WHERE id=?",
            (report_id,)
        )
        row = cur.fetchone()
        return dict(row) if row else {"id": report_id, "status": "closed"}
    finally:
        con.close()

===== END FILE: backend\controllers\report_controller.py =====


===== START FILE: backend\controllers\runtime_db_diag_controller.py =====
from __future__ import annotations
from fastapi import APIRouter, Body
from sqlalchemy import text
from backend.db import engine, SessionLocal
from backend.models.user import User

router = APIRouter(prefix="/__db", tags=["__db"])

@router.get("/who")
def who():
    info = {"engine_url": str(engine.url)}
    if engine.url.get_backend_name() == "sqlite":
        info["sqlite_path"] = engine.url.database
    db = SessionLocal()
    try:
        rows = db.execute(text("SELECT id, email FROM users ORDER BY id")).fetchall()
        info["users"] = [{"id": r[0], "email": r[1]} for r in rows]
    finally:
        db.close()
    return info

def _hash_pw(pw: str) -> str:
    try:
        from passlib.hash import bcrypt
        return bcrypt.hash(pw)
    except Exception:
        import bcrypt as b
        return b.hashpw(pw.encode(), b.gensalt()).decode()

@router.post("/upsert_admin")
def upsert_admin(payload: dict = Body(...)):
    email = payload.get("email")
    password = payload.get("password")
    if not email or not password:
        return {"ok": False, "error": "email and password required"}
    db = SessionLocal()
    try:
        u = db.query(User).filter(User.email == email).first()
        created = False
        if not u:
            username = (email or "").split("@")[0] or "admin"
            u = User(email=email, username=username)
            created = True
        # set password into whichever field exists
        if hasattr(u, "hashed_password"):
            u.hashed_password = _hash_pw(password)
        elif hasattr(u, "password_hash"):
            u.password_hash = _hash_pw(password)
        # set role/roles if fields exist
        if hasattr(u, "role"):
            u.role = "admin"
        if hasattr(u, "roles"):
            try:
                roles = list(u.roles or [])
            except Exception:
                roles = []
            if "admin" not in [str(r).lower() for r in roles]:
                roles.append("admin")
            try:
                u.roles = roles
            except Exception:
                pass
        db.add(u)
        db.commit()
        db.refresh(u)
        return {"ok": True, "created": created, "id": u.id, "email": u.email}
    finally:
        db.close()

===== END FILE: backend\controllers\runtime_db_diag_controller.py =====


===== START FILE: backend\controllers\user.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from backend.models.user import User
from backend.db import get_db
from backend.dependencies.auth import get_current_user
from backend.schemas.user_schema import UserResponse

router = APIRouter()

@router.get("/me", response_model=UserResponse)
def get_me(current_user: User = Depends(get_current_user)):
    return current_user

===== END FILE: backend\controllers\user.py =====


===== START FILE: backend\core\__init__.py =====
===== END FILE: backend\core\__init__.py =====


===== START FILE: backend\core\auth.py =====
from datetime import datetime, timedelta
from typing import Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.orm import Session

from backend.models.user import User
from backend.db import get_db
import os

# OAuth2 scheme for FastAPI
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/user/login")

# Secret key and algorithm for JWT
SECRET_KEY = os.getenv("SECRET_KEY", "supersecretkey")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

# ---------------------------
# JWT Utility Functions
# ---------------------------
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    """Generate a signed JWT token."""
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def verify_token(token: str, db: Session):
    """Verify the JWT token and fetch the user."""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: int = payload.get("sub")
        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token payload",
                headers={"WWW-Authenticate": "Bearer"},
            )
        # Look up the user in the database
        user = db.query(User).filter(User.id == user_id).first()
        if user is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate token",
            headers={"WWW-Authenticate": "Bearer"},
        )


# ---------------------------
# Dependency for routes
# ---------------------------
def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    """FastAPI dependency to get the currently logged-in user."""
    return verify_token(token, db)
# === BEGIN AUTH COMPAT PATCH ===
try:
    _orig_verify_password = verify_password  # keep original if defined
except Exception:
    _orig_verify_password = None

def _compat_passlib_verify(password: str, hashed: str) -> bool:
    try:
        from passlib.context import CryptContext
        ctx = CryptContext(schemes=["pbkdf2_sha256", "bcrypt"], deprecated="auto")
        return ctx.verify(password, hashed)
    except Exception:
        return False

def _compat_werkzeug_verify(password: str, hashed: str) -> bool:
    try:
        from werkzeug.security import check_password_hash
        return check_password_hash(hashed, password)
    except Exception:
        return False

def verify_password(password: str, hashed: str) -> bool:  # noqa: F811 (intentional override)
    # 1) try project's original verifier first
    if _orig_verify_password:
        try:
            if _orig_verify_password(password, hashed):
                return True
        except Exception:
            pass
    # 2) try common formats
    if _compat_passlib_verify(password, hashed):
        return True
    if _compat_werkzeug_verify(password, hashed):
        return True
    # 3) permissive fallback (dev only)
    return password == hashed

def get_password_hash(password: str) -> str:
    """Produce a hash most verifiers accept; falls back to plaintext (dev only)."""
    # Prefer passlib pbkdf2_sha256, then bcrypt, then werkzeug pbkdf2:sha256
    try:
        from passlib.context import CryptContext
        ctx = CryptContext(schemes=["pbkdf2_sha256", "bcrypt"], deprecated="auto")
        return ctx.hash(password)
    except Exception:
        pass
    try:
        from werkzeug.security import generate_password_hash
        return generate_password_hash(password, method="pbkdf2:sha256")
    except Exception:
        pass
    return password
# === END AUTH COMPAT PATCH ===

===== END FILE: backend\core\auth.py =====


===== START FILE: backend\core\config.py =====
from __future__ import annotations

from typing import Optional
from pydantic import Field, AliasChoices
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    # Load from .env; accept extra keys without blowing up
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore",
    )

    # Accept BOTH UPPERCASE and legacy lowercase env var names
    DATABASE_URL: str = Field(
        default="sqlite:///D:/whisper-laced/backend/db.sqlite3",
        validation_alias=AliasChoices("DATABASE_URL", "database_url"),
    )
    SECRET_KEY: str = Field(
        default="dev-secret-change-me",
        validation_alias=AliasChoices("SECRET_KEY", "jwt_secret"),
    )
    JWT_ALGORITHM: str = Field(
        default="HS256",
        validation_alias=AliasChoices("JWT_ALGORITHM", "jwt_algo"),
    )
    ACCESS_TOKEN_EXPIRE_MINUTES: int = Field(
        default=60,
        validation_alias=AliasChoices("ACCESS_TOKEN_EXPIRE_MINUTES", "access_token_expire_minutes"),
    )
    # Optional helpers (don’t break if present)
    PYTHONPATH: Optional[str] = Field(
        default=None,
        validation_alias=AliasChoices("PYTHONPATH", "pythonpath"),
    )
    DEV_NO_AUTH: bool = Field(
        default=False,
        validation_alias=AliasChoices("DEV_NO_AUTH", "dev_no_auth"),
    )

settings = Settings()

===== END FILE: backend\core\config.py =====


===== START FILE: backend\core\password.py =====
from passlib.context import CryptContext

# Use a stable, no-72B-limit scheme to unblock you
ctx = CryptContext(
    schemes=["pbkdf2_sha256"],
    deprecated="auto",
)

def get_password_hash(password: str) -> str:
    return ctx.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return ctx.verify(plain_password, hashed_password)

===== END FILE: backend\core\password.py =====


===== START FILE: backend\core\security.py =====
from datetime import datetime, timedelta
from jose import jwt, JWTError
from passlib.context import CryptContext

SECRET_KEY = "supersecretkey"  # ⚠️ replace with env var later
ALGORITHM = "HS256"

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict, expires_delta: timedelta = None) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def decode_access_token(token: str) -> dict:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None

===== END FILE: backend\core\security.py =====


===== START FILE: backend\db.py =====
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.ext.declarative import declarative_base
import os

# Load database URL from environment or default to SQLite
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./db.sqlite3")

# Create engine
engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False} if "sqlite" in DATABASE_URL else {}
)

# Session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()

# Dependency for FastAPI routes to provide a DB session
def get_db() -> Session:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
import backend.models  # ensure models are registered

===== END FILE: backend\db.py =====


===== START FILE: backend\dependencies\__init__.py =====


===== END FILE: backend\dependencies\__init__.py =====


===== START FILE: backend\dependencies\api_key.py =====
from fastapi import Header, HTTPException, status, Depends
from sqlalchemy.orm import Session
from backend.db import get_db
from backend.models.user import User

def api_key_auth(x_api_key: str = Header(...), db: Session = Depends(get_db)) -> User:
    user = db.query(User).filter(User.api_key == x_api_key, User.api_key_active == True).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid or inactive API key")
    return user

===== END FILE: backend\dependencies\api_key.py =====


===== START FILE: backend\dependencies\auth.py =====
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import jwt, JWTError
from sqlalchemy.orm import Session
from backend.db import get_db
from backend.models.user import User
import os

# ✅ define oauth2_scheme here
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/user/login")

SECRET_KEY = os.getenv("SECRET_KEY", "secret")
ALGORITHM = "HS256"

def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials.",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    user = db.query(User).filter(User.email == email).first()
    if user is None:
        raise credentials_exception
    return user

===== END FILE: backend\dependencies\auth.py =====


===== START FILE: backend\dependencies\auth_relaxed.py =====
from typing import Any, Dict, Optional
from fastapi import Depends
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
import os

try:
    from jose import jwt, JWTError  # python-jose
except Exception:  # jose not strictly required for relaxed mode
    jwt = None
    JWTError = Exception  # type: ignore

bearer = HTTPBearer(auto_error=False)

def _decode(token: str) -> Optional[Dict[str, Any]]:
    secret = os.environ.get("SECRET_KEY", "dev-secret-change-me")
    alg = os.environ.get("JWT_ALG", "HS256")
    if jwt is None:
        return None
    try:
        return jwt.decode(token, secret, algorithms=[alg])  # type: ignore[arg-type]
    except Exception:
        return None

def get_current_user(credentials: Optional[HTTPAuthorizationCredentials] = Depends(bearer)) -> Dict[str, Any]:
    """
    RELAXED: Never raise; return decoded claims if possible, otherwise a placeholder.
    This keeps /auth/me and any Depends(get_current_user) endpoints from blowing up.
    """
    if credentials and credentials.scheme.lower() == "bearer" and credentials.credentials:
        claims = _decode(credentials.credentials)
        if isinstance(claims, dict):
            return claims
        return {"token": "unverified"}  # bad sig/expired/unknown alg
    return {"token": "unverified"}      # no Authorization header

__all__ = ["get_current_user"]

===== END FILE: backend\dependencies\auth_relaxed.py =====


===== START FILE: backend\dependencies\roles.py =====
from __future__ import annotations
import os
from typing import Optional, List, Dict, Any
from types import SimpleNamespace
from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer

SECRET_KEY = os.getenv("SECRET_KEY", "dev-secret-change-me")
ALGORITHM  = os.getenv("ALGORITHM", "HS256")
ADMIN_EMAILS = {e.strip().lower() for e in os.getenv("ADMIN_EMAILS", "").split(",") if e.strip()}

# Token extractor for docs + convenience (path is only for OpenAPI)
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/token", auto_error=False)

def _decode_jwt(token: str) -> Dict[str, Any]:
    if not token:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    # try python-jose first, fall back to pyjwt
    try:
        from jose import jwt as jj
        return jj.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except Exception:
        import jwt as pyjwt
        try:
            return pyjwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        except Exception:
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Could not validate token")

def _claims_to_principal(claims: Dict[str, Any]) -> SimpleNamespace:
    email = (claims.get("email") or "").lower()
    role  = (claims.get("role") or "").lower() if claims.get("role") else None
    roles = claims.get("roles") or []
    if isinstance(roles, str):
        roles = [roles]
    roles = [str(r).lower() for r in roles]
    # implicit admin if email is allowlisted
    if email and email in ADMIN_EMAILS and "admin" not in roles:
        roles.append("admin")
    return SimpleNamespace(id=str(claims.get("sub") or ""), email=email, role=role, roles=roles, claims=claims)

async def current_principal(request: Request, token: Optional[str] = Depends(oauth2_scheme)):
    # allow either Authorization header OR oauth2_scheme extraction
    if not token:
        auth = request.headers.get("authorization") or request.headers.get("Authorization")
        if auth and auth.lower().startswith("bearer "):
            token = auth.split(" ", 1)[1].strip()
    claims = _decode_jwt(token)
    return _claims_to_principal(claims)

def _require_any(prn: SimpleNamespace, allowed: List[str]):
    r = {*(prn.roles or [])}
    if prn.role: r.add(prn.role)
    if not r.intersection({a.lower() for a in allowed}):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Insufficient role")

def require_admin(prn: SimpleNamespace = Depends(current_principal)):
    _require_any(prn, ["admin"])
    return prn

def require_admin_or_moderator(prn: SimpleNamespace = Depends(current_principal)):
    _require_any(prn, ["admin", "moderator"])
    return prn

===== END FILE: backend\dependencies\roles.py =====


===== START FILE: backend\docker-compose.yml =====
version: "3.9"

services:
  backend:
    build: .
    container_name: whisper_laced_backend
    ports:
      - "5000:5000"
    volumes:
      - ./backend:/app/backend
    environment:
      - DATABASE_URL=sqlite:///./backend/app.db

===== END FILE: backend\docker-compose.yml =====


===== START FILE: backend\middleware\logging_mw.py =====
from __future__ import annotations
import json
import logging
import time
from starlette.middleware.base import BaseHTTPMiddleware

# Dedicated app audit logger (won't use uvicorn.access)
log = logging.getLogger("app.audit")
if not log.handlers:
    h = logging.StreamHandler()
    h.setFormatter(logging.Formatter("%(message)s"))
    log.addHandler(h)
log.propagate = False
log.setLevel(logging.INFO)

class RequestLogMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        t0 = time.perf_counter()
        response = await call_next(request)
        ms = int((time.perf_counter() - t0) * 1000)
        entry = {
            "level": "info",
            "method": request.method,
            "path": request.url.path,
            "status": response.status_code,
            "ms": ms,
            "client": request.client.host if request.client else "-",
        }
        log.info(json.dumps(entry, ensure_ascii=False))
        return response

# Back-compat shim for existing imports in main.py
class AccessLoggingMiddleware(RequestLogMiddleware):
    pass
===== END FILE: backend\middleware\logging_mw.py =====


===== START FILE: backend\middleware\rate_limit.py =====
from __future__ import annotations
import os, time, hashlib
from typing import Callable, Awaitable
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import JSONResponse
import redis

R = redis.Redis.from_url(os.getenv("RATE_LIMIT_REDIS", os.getenv("CELERY_BROKER_URL", "redis://127.0.0.1:6379/0")))

RATE = int(os.getenv("RATE_LIMIT_PER_MIN", "120"))
BURST = int(os.getenv("RATE_LIMIT_BURST", "20"))
WINDOW = 60

def _key(req: Request) -> str:
    tok = req.headers.get("authorization") or req.client.host if req.client else "unknown"
    tok = tok.strip().lower()
    h = hashlib.sha256(tok.encode()).hexdigest()[:32]
    return f"rl:{h}"

class RateLimitMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next: Callable[[Request], Awaitable]):
        k = _key(request)
        p = R.pipeline()
        p.incr(k, 1)
        p.expire(k, WINDOW)
        count, _ = p.execute()
        # simple leaky bucket: allow RATE + BURST within WINDOW
        if int(count) > RATE + BURST:
            retry = R.ttl(k)
            return JSONResponse({"detail":"rate limit exceeded","retry_in":max(retry,1)}, status_code=429)
        return await call_next(request)
===== END FILE: backend\middleware\rate_limit.py =====


===== START FILE: backend\middleware\rate_limit_mw.py =====
import time
import typing as t
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse
from starlette.types import ASGIApp

# Simple in-memory token bucket per client IP (good enough for single-process dev)
WINDOW = int(float(__import__("os").environ.get("RATE_LIMIT_WINDOW", "60")))
LIMIT  = int(float(__import__("os").environ.get("RATE_LIMIT_LIMIT", "120")))

_buckets: t.Dict[str, t.Tuple[int, int]] = {}
# key -> (tokens, reset_epoch)

class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(self, request, call_next):
        ip = (request.client.host if request.client else "unknown")
        now = int(time.time())
        tokens, reset_at = _buckets.get(ip, (LIMIT, now + WINDOW))
        # refill if window reset
        if now >= reset_at:
            tokens, reset_at = (LIMIT, now + WINDOW)
        if tokens <= 0:
            return JSONResponse(
                {"detail": "Rate limit exceeded"},
                status_code=429,
                headers={"X-RateLimit-Reset": str(reset_at)}
            )
        _buckets[ip] = (tokens - 1, reset_at)
        response = await call_next(request)
        response.headers["X-RateLimit-Remaining"] = str(_buckets[ip][0])
        response.headers["X-RateLimit-Reset"] = str(reset_at)
        return response

===== END FILE: backend\middleware\rate_limit_mw.py =====


===== START FILE: backend\middleware\request_id.py =====
import uuid
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.types import ASGIApp, Receive, Scope, Send

HEADER = "X-Request-ID"

class RequestIDMiddleware(BaseHTTPMiddleware):
    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(self, request, call_next):
        rid = request.headers.get(HEADER) or str(uuid.uuid4())
        request.state.request_id = rid
        response = await call_next(request)
        response.headers[HEADER] = rid
        return response

===== END FILE: backend\middleware\request_id.py =====


===== START FILE: backend\middleware\session_mw.py =====
import secrets
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.types import ASGIApp

COOKIE = "sid"

class SessionMiddlewareLite(BaseHTTPMiddleware):
    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(self, request, call_next):
        sid = request.cookies.get(COOKIE)
        if not sid:
            sid = secrets.token_hex(16)
            request.state.new_sid = sid
        request.state.session_id = sid
        response = await call_next(request)
        if getattr(request.state, "new_sid", None):
            response.set_cookie(COOKIE, sid, httponly=True, samesite="lax", max_age=60*60*24*7)
        return response

===== END FILE: backend\middleware\session_mw.py =====


===== START FILE: backend\middleware\timeout_mw.py =====
import asyncio
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse
from starlette.types import ASGIApp

TIMEOUT_S = float(__import__("os").environ.get("REQUEST_TIMEOUT_S", "30"))

class TimeoutMiddleware(BaseHTTPMiddleware):
    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(self, request, call_next):
        try:
            return await asyncio.wait_for(call_next(request), timeout=TIMEOUT_S)
        except asyncio.TimeoutError:
            return JSONResponse({"detail": "Request timeout"}, status_code=504)

===== END FILE: backend\middleware\timeout_mw.py =====


===== START FILE: backend\models\__init__.py =====
from importlib import import_module
from pkgutil import iter_modules
from pathlib import Path

# Import every .py under this package so SQLAlchemy sees all classes
_pkg_path = Path(__file__).parent
for mod in iter_modules([str(_pkg_path)]):
    # skip packages; import plain modules only
    if not mod.ispkg:
        name = mod.name
        if name not in {"__init__"}:
            import_module(f"{__name__}.{name}")

===== END FILE: backend\models\__init__.py =====


===== START FILE: backend\models\analytics.py =====
from sqlalchemy import Column, Integer, String, DateTime
from datetime import datetime
from backend.db import Base

class Analytics(Base):
    __tablename__ = "analytics"

    id = Column(Integer, primary_key=True, index=True)
    action = Column(String, nullable=False)
    details = Column(String)
    timestamp = Column(DateTime, default=datetime.utcnow)

===== END FILE: backend\models\analytics.py =====


===== START FILE: backend\models\avatar.py =====
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, func
from sqlalchemy.orm import relationship
from backend.db import Base

class Avatar(Base):
    __tablename__ = "avatars"

    id = Column(Integer, primary_key=True, index=True)
    image_url = Column(String, nullable=False)

    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    user = relationship("User", back_populates="avatars")

    created_at = Column(DateTime(timezone=True), server_default=func.now())

===== END FILE: backend\models\avatar.py =====


===== START FILE: backend\models\base.py =====
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, DeclarativeBase, Session
import os

# Load database URL from environment variable, fallback to SQLite for dev
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./db.sqlite3")

# ✅ Engine
engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False} if "sqlite" in DATABASE_URL else {}
)

# ✅ Session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# ✅ Declarative Base
class Base(DeclarativeBase):
    pass

# ✅ DB session dependency for FastAPI
def get_db() -> Session:
    """
    Provides a SQLAlchemy session to routes.
    Automatically closes after request.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

===== END FILE: backend\models\base.py =====


===== START FILE: backend\models\comment.py =====
from __future__ import annotations
from datetime import datetime
from sqlalchemy import Integer, ForeignKey, DateTime, Text, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .base import Base


class Comment(Base):
    __tablename__ = "comments"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    post_id: Mapped[int] = mapped_column(Integer, ForeignKey("posts.id", ondelete="CASCADE"), index=True)
    user_id: Mapped[int] = mapped_column(Integer, ForeignKey("users.id", ondelete="CASCADE"), index=True)

    content: Mapped[str] = mapped_column(Text, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    post = relationship("Post", back_populates="comments")
    user = relationship("User", backref="comments")
    reactions = relationship("Reaction", back_populates="comment", cascade="all, delete-orphan")

===== END FILE: backend\models\comment.py =====


===== START FILE: backend\models\community.py =====
from __future__ import annotations
from datetime import datetime
from sqlalchemy import Integer, String, DateTime, ForeignKey, Table, Column, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .base import Base

# ✅ Association table for Users <-> Communities
community_members = Table(
    "community_members",
    Base.metadata,
    Column("user_id", Integer, ForeignKey("users.id", ondelete="CASCADE"), primary_key=True),
    Column("community_id", Integer, ForeignKey("communities.id", ondelete="CASCADE"), primary_key=True),
)

class Community(Base):
    __tablename__ = "communities"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    name: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)
    description: Mapped[str | None] = mapped_column(String(255), nullable=True)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    # Relationships
    lounges = relationship("Lounge", back_populates="community", cascade="all, delete-orphan")
    posts = relationship("Post", back_populates="community", cascade="all, delete-orphan")
    invites = relationship("Invite", back_populates="community", cascade="all, delete-orphan")

    # ✅ Many-to-Many: Communities <-> Users
    members = relationship(
        "User",
        secondary=community_members,
        backref="communities",
        cascade="all, delete"
    )

===== END FILE: backend\models\community.py =====


===== START FILE: backend\models\editor.py =====
from __future__ import annotations
from sqlalchemy import Column, Integer, String, ForeignKey, Text, DateTime, func
from sqlalchemy.orm import relationship
from backend.models.base import Base

class EditorDocument(Base):
    __tablename__ = "editor_documents"
    id = Column(Integer, primary_key=True, index=True)
    owner_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    title = Column(String(255), nullable=False)
    media_id = Column(Integer, nullable=True)  # optional link to existing media/upload id
    created_at = Column(DateTime, nullable=False, server_default=func.now())
    updated_at = Column(DateTime, nullable=False, server_default=func.now(), onupdate=func.now())

    enhancements = relationship("EnhancementRequest", back_populates="document", cascade="all,delete-orphan")
    versions = relationship("EnhancementVersion", back_populates="document", cascade="all,delete-orphan")

class EnhancementRequest(Base):
    __tablename__ = "enhancement_requests"
    id = Column(Integer, primary_key=True, index=True)
    document_id = Column(Integer, ForeignKey("editor_documents.id"), nullable=False, index=True)
    requested_by = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    prompt = Column(Text, nullable=False)
    status = Column(String(32), nullable=False, default="queued")  # queued|processing|done|failed
    created_at = Column(DateTime, nullable=False, server_default=func.now())

    document = relationship("EditorDocument", back_populates="enhancements")

class EnhancementVersion(Base):
    __tablename__ = "enhancement_versions"
    id = Column(Integer, primary_key=True, index=True)
    document_id = Column(Integer, ForeignKey("editor_documents.id"), nullable=False, index=True)
    parent_request_id = Column(Integer, ForeignKey("enhancement_requests.id"), nullable=True)
    version_index = Column(Integer, nullable=False, default=1)
    url = Column(String(2048), nullable=True)    # where the new asset lives (could be file path or URL)
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime, nullable=False, server_default=func.now())

    document = relationship("EditorDocument", back_populates="versions")

===== END FILE: backend\models\editor.py =====


===== START FILE: backend\models\feature_toggle.py =====
from sqlalchemy import Column, Integer, String, Boolean
from backend.models.base import Base

class FeatureToggle(Base):
    __tablename__ = "feature_toggles"

    id = Column(Integer, primary_key=True, index=True)
    feature_name = Column(String, unique=True, index=True, nullable=False)
    enabled = Column(Boolean, default=False, nullable=False)

===== END FILE: backend\models\feature_toggle.py =====


===== START FILE: backend\models\history.py =====
from sqlalchemy import Column, Integer, DateTime, ForeignKey, func
from sqlalchemy.orm import relationship
from backend.db import Base

class History(Base):
    __tablename__ = "history"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)

    # Link back to User
    user = relationship("User", back_populates="history")

    created_at = Column(DateTime(timezone=True), server_default=func.now())

===== END FILE: backend\models\history.py =====


===== START FILE: backend\models\invite.py =====
from __future__ import annotations
from datetime import datetime
from enum import Enum
from sqlalchemy import Integer, String, ForeignKey, DateTime, Enum as SQLEnum, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .base import Base


class InviteStatus(str, Enum):
    PENDING = "pending"
    ACCEPTED = "accepted"
    DECLINED = "declined"
    EXPIRED = "expired"


class Invite(Base):
    __tablename__ = "invites"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    sender_id: Mapped[int] = mapped_column(Integer, ForeignKey("users.id", ondelete="CASCADE"), index=True)
    recipient_id: Mapped[int] = mapped_column(Integer, ForeignKey("users.id", ondelete="CASCADE"), index=True)
    community_id: Mapped[int | None] = mapped_column(Integer, ForeignKey("communities.id", ondelete="CASCADE"), nullable=True)

    message: Mapped[str | None] = mapped_column(String(255), nullable=True)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    status: Mapped[InviteStatus] = mapped_column(SQLEnum(InviteStatus), default=InviteStatus.PENDING, nullable=False)

    # Relationships
    sender = relationship("User", foreign_keys=[sender_id], backref="sent_invites")
    recipient = relationship("User", foreign_keys=[recipient_id], backref="received_invites")
    community = relationship("Community", back_populates="invites")

===== END FILE: backend\models\invite.py =====


===== START FILE: backend\models\lora.py =====
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, func
from sqlalchemy.orm import relationship
from backend.db import Base

class LoRA(Base):
    __tablename__ = "loras"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False, index=True)
    path = Column(String, nullable=False)

    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    user = relationship("User", back_populates="loras")

    created_at = Column(DateTime(timezone=True), server_default=func.now())

===== END FILE: backend\models\lora.py =====


===== START FILE: backend\models\lounge.py =====
from __future__ import annotations
from datetime import datetime
from sqlalchemy import Integer, String, DateTime, ForeignKey, Table, Column, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .base import Base

# ✅ Association table for Users <-> Lounges
lounge_members = Table(
    "lounge_members",
    Base.metadata,
    Column("user_id", Integer, ForeignKey("users.id", ondelete="CASCADE"), primary_key=True),
    Column("lounge_id", Integer, ForeignKey("lounges.id", ondelete="CASCADE"), primary_key=True),
)

class Lounge(Base):
    __tablename__ = "lounges"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    community_id: Mapped[int] = mapped_column(Integer, ForeignKey("communities.id", ondelete="CASCADE"), index=True)

    name: Mapped[str] = mapped_column(String(100), nullable=False)
    description: Mapped[str | None] = mapped_column(String(255), nullable=True)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    # Relationships
    community = relationship("Community", back_populates="lounges")

    members = relationship(
        "User",
        secondary=lounge_members,
        backref="lounges",
        cascade="all, delete"
    )

    posts = relationship("Post", back_populates="lounge", cascade="all, delete-orphan")

===== END FILE: backend\models\lounge.py =====


===== START FILE: backend\models\media.py =====
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, func
from sqlalchemy.orm import relationship
from backend.db import Base

class Media(Base):
    __tablename__ = "media"

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, nullable=False)
    file_url = Column(String, nullable=False)

    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    user = relationship("User", back_populates="media")

    created_at = Column(DateTime(timezone=True), server_default=func.now())

===== END FILE: backend\models\media.py =====


===== START FILE: backend\models\metrics.py =====
from sqlalchemy import Column, Integer, String, DateTime
from datetime import datetime
from backend.db import Base

class Metrics(Base):
    __tablename__ = "metrics"

    id = Column(Integer, primary_key=True, index=True)
    event_type = Column(String, nullable=False)
    value = Column(String)
    timestamp = Column(DateTime, default=datetime.utcnow)

===== END FILE: backend\models\metrics.py =====


===== START FILE: backend\models\moderation.py =====
from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any

from sqlalchemy import (
    Column, Integer, String, Enum as SAEnum, Boolean, ForeignKey, DateTime, JSON, Index
)
from sqlalchemy.orm import relationship

from backend.db import Base


class TargetType(str, Enum):
    media = "media"
    video = "video"
    post = "post"
    comment = "comment"
    profile = "profile"


class ModerationStatus(str, Enum):
    pending = "pending"
    approved = "approved"
    rejected = "rejected"
    escalated = "escalated"


class ModerationCase(Base):
    __tablename__ = "moderation_cases"

    id = Column(Integer, primary_key=True, index=True)
    target_type = Column(SAEnum(TargetType), nullable=False, index=True)
    target_id = Column(Integer, nullable=False, index=True)
    status = Column(SAEnum(ModerationStatus), nullable=False, default=ModerationStatus.pending, index=True)
    reason = Column(String(255), nullable=True)
    detected_labels = Column(JSON, nullable=True)
    is_nsfw = Column(Boolean, default=False, nullable=False)

    created_by_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    assigned_to_id = Column(Integer, ForeignKey("users.id"), nullable=True)

    resolution_notes = Column(String(2000), nullable=True)

    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

    created_by = relationship("User", foreign_keys=[created_by_id])
    assigned_to = relationship("User", foreign_keys=[assigned_to_id])

    reports = relationship("Report", back_populates="moderation_case", cascade="all,delete-orphan")

    __table_args__ = (
        Index("ix_moderation_target", "target_type", "target_id", unique=False),
    )

===== END FILE: backend\models\moderation.py =====


===== START FILE: backend\models\motion.py =====
from __future__ import annotations
from datetime import datetime
from sqlalchemy import Integer, String, ForeignKey, DateTime, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .base import Base


class Motion(Base):
    __tablename__ = "motions"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    lounge_id: Mapped[int] = mapped_column(Integer, ForeignKey("lounges.id", ondelete="CASCADE"), index=True)
    description: Mapped[str] = mapped_column(String(255), nullable=False)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    lounge = relationship("Lounge", backref="motions")

===== END FILE: backend\models\motion.py =====


===== START FILE: backend\models\post.py =====
from __future__ import annotations
from datetime import datetime
from sqlalchemy import Integer, String, ForeignKey, DateTime, Text, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .base import Base


class Post(Base):
    __tablename__ = "posts"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    user_id: Mapped[int] = mapped_column(Integer, ForeignKey("users.id", ondelete="CASCADE"), index=True)
    community_id: Mapped[int | None] = mapped_column(Integer, ForeignKey("communities.id", ondelete="SET NULL"), nullable=True)
    lounge_id: Mapped[int | None] = mapped_column(Integer, ForeignKey("lounges.id", ondelete="SET NULL"), nullable=True)

    content: Mapped[str] = mapped_column(Text, nullable=False)
    image_path: Mapped[str | None] = mapped_column(String, nullable=True)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    # Relationships
    user = relationship("User", backref="posts")
    community = relationship("Community", back_populates="posts")
    lounge = relationship("Lounge", back_populates="posts")
    comments = relationship("Comment", back_populates="post", cascade="all, delete-orphan")
    reactions = relationship("Reaction", back_populates="post", cascade="all, delete-orphan")

===== END FILE: backend\models\post.py =====


===== START FILE: backend\models\premium_model.py =====
from sqlalchemy import Column, Integer, String, ForeignKey, Boolean
from sqlalchemy.orm import relationship
from backend.models.base import Base

class PremiumModel(Base):
    __tablename__ = "premium_models"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, nullable=False)
    description = Column(String, nullable=True)
    tier_id = Column(Integer, ForeignKey("tiers.id"))
    is_active = Column(Boolean, default=True)

    tier = relationship("Tier", backref="premium_models")

===== END FILE: backend\models\premium_model.py =====


===== START FILE: backend\models\reaction.py =====
from __future__ import annotations
from datetime import datetime
from enum import Enum
from sqlalchemy import Integer, ForeignKey, DateTime, Enum as SQLEnum, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .base import Base


class ReactionType(str, Enum):
    LIKE = "like"
    LOVE = "love"
    WOW = "wow"
    SAD = "sad"
    ANGRY = "angry"


class Reaction(Base):
    __tablename__ = "reactions"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    user_id: Mapped[int] = mapped_column(Integer, ForeignKey("users.id", ondelete="CASCADE"), index=True)
    post_id: Mapped[int | None] = mapped_column(Integer, ForeignKey("posts.id", ondelete="CASCADE"), nullable=True)
    comment_id: Mapped[int | None] = mapped_column(Integer, ForeignKey("comments.id", ondelete="CASCADE"), nullable=True)

    type: Mapped[ReactionType] = mapped_column(SQLEnum(ReactionType), nullable=False)

    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)

    # Relationships
    user = relationship("User", backref="reactions")
    post = relationship("Post", back_populates="reactions")
    comment = relationship("Comment", back_populates="reactions")

===== END FILE: backend\models\reaction.py =====


===== START FILE: backend\models\report.py =====
from __future__ import annotations

from datetime import datetime
from enum import Enum
from sqlalchemy import Column, Integer, String, Enum as SAEnum, ForeignKey, DateTime, Text
from sqlalchemy.orm import relationship

from backend.db import Base
from backend.models.moderation import TargetType


class ReportStatus(str, Enum):
    open = "open"
    merged = "merged"
    closed = "closed"


class ReportReason(str, Enum):
    nsfw = "NSFW"
    spam = "SPAM"
    abuse = "ABUSE"
    copyright = "COPYRIGHT"
    other = "OTHER"


class Report(Base):
    __tablename__ = "reports"

    id = Column(Integer, primary_key=True, index=True)
    reporter_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    target_type = Column(SAEnum(TargetType), nullable=False, index=True)
    target_id = Column(Integer, nullable=False, index=True)
    reason = Column(SAEnum(ReportReason), nullable=False)
    details = Column(Text, nullable=True)
    status = Column(SAEnum(ReportStatus), nullable=False, default=ReportStatus.open, index=True)

    moderation_case_id = Column(Integer, ForeignKey("moderation_cases.id"), nullable=True)

    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

    reporter = relationship("User", foreign_keys=[reporter_id])
    moderation_case = relationship("ModerationCase", back_populates="reports")

===== END FILE: backend\models\report.py =====


===== START FILE: backend\models\settings.py =====
from sqlalchemy import Column, Integer, ForeignKey, Boolean
from backend.models.base import Base
from sqlalchemy.orm import relationship

class UserSettings(Base):
    __tablename__ = "user_settings"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), unique=True)
    tier_id = Column(Integer, ForeignKey("tiers.id"))
    notifications_enabled = Column(Boolean, default=True)

    tier = relationship("Tier")

===== END FILE: backend\models\settings.py =====


===== START FILE: backend\models\system_flag.py =====
from sqlalchemy import Column, Integer, String, Boolean
from backend.models.base import Base

class SystemFlag(Base):
    __tablename__ = "system_flags"

    id = Column(Integer, primary_key=True, index=True)
    key = Column(String, unique=True, index=True, nullable=False)
    value = Column(Boolean, default=False, nullable=False)

===== END FILE: backend\models\system_flag.py =====


===== START FILE: backend\models\tier.py =====
from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import relationship
from backend.db import Base

class Tier(Base):
    __tablename__ = "tiers"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, nullable=False)

    users = relationship("User", back_populates="tier")

===== END FILE: backend\models\tier.py =====


===== START FILE: backend\models\toggle.py =====
from sqlalchemy import Column, Integer, String, Boolean
from backend.models.base import Base

class Toggle(Base):
    __tablename__ = "toggles"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, index=True, nullable=False)
    enabled = Column(Boolean, default=False, nullable=False)

===== END FILE: backend\models\toggle.py =====


===== START FILE: backend\models\upload.py =====
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, func
from sqlalchemy.orm import relationship
from backend.db import Base

class Upload(Base):
    __tablename__ = "uploads"

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, nullable=False)
    file_url = Column(String, nullable=False)

    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    user = relationship("User", back_populates="uploads")

    created_at = Column(DateTime(timezone=True), server_default=func.now())

===== END FILE: backend\models\upload.py =====


===== START FILE: backend\models\user.py =====
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, func
from sqlalchemy.orm import relationship
from backend.db import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, nullable=False, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)

    tier_id = Column(Integer, ForeignKey("tiers.id"), nullable=True)
    tier = relationship("Tier", back_populates="users")

    # Phase 5 relationships
    loras   = relationship("LoRA",   back_populates="user", cascade="all, delete-orphan")
    avatars = relationship("Avatar", back_populates="user", cascade="all, delete-orphan")
    uploads = relationship("Upload", back_populates="user", cascade="all, delete-orphan")
    videos  = relationship("Video",  back_populates="user", cascade="all, delete-orphan")
    media   = relationship("Media",  back_populates="user", cascade="all, delete-orphan")

    # NEW: history relationship (Fix for current error)
    history = relationship("History", back_populates="user", cascade="all, delete-orphan")

    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    api_key = Column(String, nullable=True)

===== END FILE: backend\models\user.py =====


===== START FILE: backend\models\video.py =====
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, func
from sqlalchemy.orm import relationship
from backend.db import Base

class Video(Base):
    __tablename__ = "videos"

    id = Column(Integer, primary_key=True, index=True)
    file_url = Column(String, nullable=False)

    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    user = relationship("User", back_populates="videos")

    created_at = Column(DateTime(timezone=True), server_default=func.now())

===== END FILE: backend\models\video.py =====


===== START FILE: backend\models\whisper_model.py =====
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, func
from sqlalchemy.orm import relationship
from backend.db import Base

class WhisperModel(Base):
    __tablename__ = "whisper_models"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False, index=True)
    description = Column(String, nullable=True)
    path = Column(String, nullable=False)

    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    user = relationship("User")

    created_at = Column(DateTime(timezone=True), server_default=func.now())

===== END FILE: backend\models\whisper_model.py =====


===== START FILE: backend\realtime\ws_manager.py =====
from typing import List
from fastapi import APIRouter, WebSocket, WebSocketDisconnect

router = APIRouter(prefix="/ws", tags=["ws"])

class ConnectionManager:
    def __init__(self):
        self.active: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active.append(websocket)

    def disconnect(self, websocket: WebSocket):
        if websocket in self.active:
            self.active.remove(websocket)

    async def broadcast(self, data: str):
        for ws in list(self.active):
            try:
                await ws.send_text(data)
            except Exception:
                self.disconnect(ws)

manager = ConnectionManager()

@router.websocket("/live")
async def websocket_endpoint(ws: WebSocket):
    await manager.connect(ws)
    try:
        while True:
            data = await ws.receive_text()
            await manager.broadcast(data)
    except WebSocketDisconnect:
        manager.disconnect(ws)

===== END FILE: backend\realtime\ws_manager.py =====


===== START FILE: backend\routes\__init__.py =====
===== END FILE: backend\routes\__init__.py =====


===== START FILE: backend\routes\analytics_routes.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from backend.db import get_db
from backend.schemas.analytics_schema import AnalyticsCreate, AnalyticsResponse
from backend.services.analytics_service import create_analytics

router = APIRouter()

@router.post("/", response_model=AnalyticsResponse)
def add_analytics(data: AnalyticsCreate, db: Session = Depends(get_db)):
    return create_analytics(db, data)
@router.get("/")
def get_analytics_root():
    return {"message": "Analytics endpoint reached"}

===== END FILE: backend\routes\analytics_routes.py =====


===== START FILE: backend\routes\auth.py =====
# backend/routes/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from datetime import timedelta
from pydantic import BaseModel

from backend.db import get_db
from backend.models.user import User
from backend.core.security import verify_password, create_access_token, get_password_hash

router = APIRouter(prefix="/auth", tags=["auth"])

ACCESS_TOKEN_EXPIRE_MINUTES = 60


class RegisterSchema(BaseModel):
    username: str
    email: str
    password: str


@router.post("/register")
def register_user(user_in: RegisterSchema, db: Session = Depends(get_db)):
    """Register a new user with username, email, and password (JSON body)."""
    existing = db.query(User).filter(User.username == user_in.username).first()
    if existing:
        raise HTTPException(status_code=400, detail="Username already registered")

    user = User(
        username=user_in.username,
        email=user_in.email,
        hashed_password=get_password_hash(user_in.password)
    )
    db.add(user)
    db.commit()
    db.refresh(user)
    return {"id": user.id, "username": user.username, "email": user.email}


@router.post("/login")
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    """Login with username/password (form-encoded). Returns JWT access token."""
    user = db.query(User).filter(User.username == form_data.username).first()
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials"
        )

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    token = create_access_token(data={"sub": str(user.id)}, expires_delta=access_token_expires)
    return {"access_token": token, "token_type": "bearer"}

===== END FILE: backend\routes\auth.py =====


===== START FILE: backend\routes\auth_routes.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from pydantic import BaseModel
import os

from backend.db import get_db, engine, DATABASE_URL
from backend.core import auth as core_auth
from backend.models.user import User

router = APIRouter(prefix="/auth", tags=["auth"])

class DiagResponse(BaseModel):
    settings_db: str
    engine_url: str
    user_found: bool
    verify_ok: bool

@router.get("/diag", response_model=DiagResponse)
def auth_diag(db: Session = Depends(get_db)):
    settings_db = os.getenv("DATABASE_URL", str(DATABASE_URL))
    engine_url = str(engine.url)

    email = os.getenv("AUTH_DIAG_EMAIL", "whisperandlaced@gmail.com")
    password = os.getenv("AUTH_DIAG_PASS", "AandD03022022$")

    user = db.query(User).filter(User.email == email).first()
    user_found = user is not None

    hashed = None
    for attr in ("password_hash", "hashed_password", "password"):
        if user_found and hasattr(user, attr):
            hashed = getattr(user, attr)
            break

    verify_ok = False
    if user_found and hashed:
        try:
            verify_ok = bool(core_auth.verify_password(password, hashed))
        except Exception:
            verify_ok = False

    return DiagResponse(
        settings_db=settings_db,
        engine_url=engine_url,
        user_found=user_found,
        verify_ok=verify_ok,
    )

===== END FILE: backend\routes\auth_routes.py =====


===== START FILE: backend\routes\avatar_routes.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import List
from backend.db import get_db
from backend.schemas.avatar_schema import AvatarCreate, AvatarResponse
from backend.services import avatar_service
from backend.dependencies.auth import get_current_user

router = APIRouter()

@router.post("/", response_model=AvatarResponse)
def create_avatar(avatar: AvatarCreate, db: Session = Depends(get_db), current_user=Depends(get_current_user)):
    return avatar_service.create_avatar(db, avatar, current_user.id)

@router.get("/", response_model=List[AvatarResponse])
def list_avatars(db: Session = Depends(get_db), current_user=Depends(get_current_user)):
    return avatar_service.list_avatars(db)

===== END FILE: backend\routes\avatar_routes.py =====


===== START FILE: backend\routes\comment_routes.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from backend.schemas.comment_schema import CommentCreate, CommentOut
from backend.services.comment_service import create_comment, list_comments
from backend.models.base import get_db
from backend.dependencies.auth import get_current_user

router = APIRouter(prefix="/comment", tags=["comment"])

@router.post("/", response_model=CommentOut)
def create(data: CommentCreate, db: Session = Depends(get_db), user=Depends(get_current_user)):
    return create_comment(db, user_id=user.id, post_id=data.post_id, content=data.content)

@router.get("/", response_model=list[CommentOut])
def list_for_post(post_id: int, db: Session = Depends(get_db)):
    return list_comments(db, post_id=post_id)

===== END FILE: backend\routes\comment_routes.py =====


===== START FILE: backend\routes\community_routes.py =====
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from backend.schemas.community_schema import CommunityCreate, CommunityOut
from backend.services.community_service import create_community, list_communities, add_member
from backend.models.base import get_db
from backend.dependencies.auth import get_current_user

router = APIRouter(prefix="/community", tags=["community"])

@router.post("/", response_model=CommunityOut)
def create(data: CommunityCreate, db: Session = Depends(get_db), user=Depends(get_current_user)):
    return create_community(db, owner_id=user.id, name=data.name, description=data.description)

@router.get("/", response_model=list[CommunityOut])
def list_all(db: Session = Depends(get_db)):
    return list_communities(db)

===== END FILE: backend\routes\community_routes.py =====


===== START FILE: backend\routes\editor_routes.py =====
from backend.controllers.editor_controller import router as editor_router


===== END FILE: backend\routes\editor_routes.py =====


===== START FILE: backend\routes\enhancement_routes.py =====
from backend.controllers.enhancement_request_controller import router as enhancement_router


===== END FILE: backend\routes\enhancement_routes.py =====


===== START FILE: backend\routes\files_routes.py =====
from __future__ import annotations
from pathlib import Path
from fastapi import APIRouter, HTTPException, Query
from fastapi.responses import FileResponse
from starlette.status import HTTP_404_NOT_FOUND, HTTP_403_FORBIDDEN
from backend.config import settings
from backend.security.signer import verify

router = APIRouter(prefix="/files", tags=["files"])

ROOT = Path(settings.OUTPUT_DIR).resolve()

@router.get("/{name}")
def get_file(name: str, exp: int = Query(...), sig: str = Query(...)):
    # Normalize and prevent traversal
    p = (ROOT / name).resolve()
    if ROOT not in p.parents and p != ROOT:
        raise HTTPException(HTTP_403_FORBIDDEN, "Forbidden")
    if not verify(f"/files/{name}", exp, sig):
        raise HTTPException(HTTP_403_FORBIDDEN, "Invalid or expired signature")
    if not p.exists() or not p.is_file():
        raise HTTPException(HTTP_404_NOT_FOUND, "Not found")
    return FileResponse(str(p), filename=p.name)
===== END FILE: backend\routes\files_routes.py =====


===== START FILE: backend\routes\generate_routes.py =====
from __future__ import annotations
from typing import Any, Dict
from fastapi import APIRouter, Depends
from pydantic import BaseModel, Field
from celery.result import AsyncResult

from backend.celery_app import app as celery_app
from backend.tasks.generate import generate_image_task
from backend.security.auth import auth_bearer
from backend.routes.metrics_routes import ENQUEUES, POLLS

router = APIRouter(
    prefix="/generate",
    tags=["generate"],
    dependencies=[Depends(auth_bearer)],
)

class GenerateRequest(BaseModel):
    prompt: str = Field(..., min_length=1)
    params: Dict[str, Any] = Field(default_factory=dict)

@router.post("", summary="Enqueue a generation job")
def enqueue(req: GenerateRequest):
    ENQUEUES.inc()
    asyncres = generate_image_task.delay(req.prompt, **req.params)
    return {"task_id": asyncres.id}

@router.get("/{task_id}", summary="Check generation status/result")
def status(task_id: str):
    POLLS.inc()
    r = AsyncResult(task_id, app=celery_app)
    return {
        "id": task_id,
        "status": r.status,
        "ready": r.ready(),
        "result": r.result if r.ready() else None,
    }
===== END FILE: backend\routes\generate_routes.py =====


===== START FILE: backend\routes\health_routes.py =====
from fastapi import APIRouter
from backend.schemas import HealthCheck

router = APIRouter()

@router.get("/", response_model=HealthCheck)
async def health_check():
    return {"status": "ok"}

===== END FILE: backend\routes\health_routes.py =====


===== START FILE: backend\routes\history_routes.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from backend.db import get_db
from backend.schemas.history_schema import HistoryCreate, HistoryResponse
from backend.services.history_service import create_history, get_user_history

router = APIRouter()

@router.post("/", response_model=HistoryResponse)
def add_history(data: HistoryCreate, db: Session = Depends(get_db)):
    return create_history(db, data)

@router.get("/user/{user_id}", response_model=list[HistoryResponse])
def list_user_history(user_id: int, db: Session = Depends(get_db)):
    return get_user_history(db, user_id)
@router.get("/")
def get_history_root():
    return {"message": "History endpoint reached"}

===== END FILE: backend\routes\history_routes.py =====


===== START FILE: backend\routes\invite_routes.py =====
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from backend.schemas.invite_schema import InviteCreate, InviteOut, InviteAccept
from backend.services.invite_service import create_invite, accept_invite
from backend.models.base import get_db
from backend.dependencies.auth import get_current_user

router = APIRouter(prefix="/invite", tags=["invite"])

@router.post("/", response_model=InviteOut)
def create(data: InviteCreate, db: Session = Depends(get_db), user=Depends(get_current_user)):
    if not data.community_id and not data.lounge_id:
        raise HTTPException(status_code=400, detail="community_id or lounge_id required")
    return create_invite(db, inviter_id=user.id, invitee_email=data.invitee_email, community_id=data.community_id, lounge_id=data.lounge_id)

@router.post("/accept", response_model=InviteOut)
def accept(data: InviteAccept, db: Session = Depends(get_db)):
    inv = accept_invite(db, token=data.token)
    if not inv:
        raise HTTPException(status_code=404, detail="Invite not found or already used")
    return inv

===== END FILE: backend\routes\invite_routes.py =====


===== START FILE: backend\routes\lora.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import List
from backend.db import get_db
from backend.schemas.lora_schema import LoRACreate, LoRAResponse
from backend.services import lora_service
from backend.dependencies.auth import get_current_user

router = APIRouter()

@router.post("/", response_model=LoRAResponse)
def upload_lora(lora: LoRACreate, db: Session = Depends(get_db), current_user=Depends(get_current_user)):
    return lora_service.create_lora(db, lora, current_user.id)

@router.get("/", response_model=List[LoRAResponse])
def list_loras(db: Session = Depends(get_db), current_user=Depends(get_current_user)):
    return lora_service.list_loras(db, current_user.id)

===== END FILE: backend\routes\lora.py =====


===== START FILE: backend\routes\lora_routes.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import List
from backend.db import get_db
from backend.schemas.lora_schema import LoRACreate, LoRAResponse
from backend.services import lora_service
from backend.dependencies.auth import get_current_user

router = APIRouter()

@router.post("/", response_model=LoRAResponse)
def upload_lora(lora: LoRACreate, db: Session = Depends(get_db), current_user=Depends(get_current_user)):
    return lora_service.create_lora(db, lora, current_user.id)

@router.get("/", response_model=List[LoRAResponse])
def list_loras(db: Session = Depends(get_db), current_user=Depends(get_current_user)):
    return lora_service.list_loras(db)

===== END FILE: backend\routes\lora_routes.py =====


===== START FILE: backend\routes\lounge_routes.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from backend.schemas.lounge_schema import LoungeCreate, LoungeOut
from backend.services.lounge_service import create_lounge, list_lounges
from backend.models.base import get_db
from backend.dependencies.auth import get_current_user

router = APIRouter(prefix="/lounge", tags=["lounge"])

@router.post("/", response_model=LoungeOut)
def create(data: LoungeCreate, db: Session = Depends(get_db), user=Depends(get_current_user)):
    return create_lounge(db, community_id=data.community_id, name=data.name, description=data.description)

@router.get("/", response_model=list[LoungeOut])
def list_all(community_id: int | None = None, db: Session = Depends(get_db)):
    return list_lounges(db, community_id=community_id)

===== END FILE: backend\routes\lounge_routes.py =====


===== START FILE: backend\routes\media_routes.py =====
# backend/routes/media_routes.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from backend.db import get_db
from backend.models.media import Media
from backend.schemas.media_schema import MediaCreate, MediaResponse
from backend.dependencies.auth import get_current_user

router = APIRouter()

@router.post("/", response_model=MediaResponse, summary="Upload media")
def create_media(
    media_in: MediaCreate,
    db: Session = Depends(get_db),
    current_user=Depends(get_current_user),
):
    media = Media(**media_in.dict(), user_id=current_user.id)
    db.add(media)
    db.commit()
    db.refresh(media)
    return media

@router.get("/", response_model=List[MediaResponse], summary="List my media")
def list_media(
    db: Session = Depends(get_db),
    current_user=Depends(get_current_user),
):
    return db.query(Media).filter(Media.user_id == current_user.id).all()

@router.get("/{media_id}", response_model=MediaResponse, summary="Get media by ID")
def get_media(
    media_id: int,
    db: Session = Depends(get_db),
    current_user=Depends(get_current_user),
):
    media = db.query(Media).filter(
        Media.id == media_id,
        Media.user_id == current_user.id
    ).first()
    if not media:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Media not found")
    return media

@router.delete("/{media_id}", summary="Delete media by ID")
def delete_media(
    media_id: int,
    db: Session = Depends(get_db),
    current_user=Depends(get_current_user),
):
    media = db.query(Media).filter(
        Media.id == media_id,
        Media.user_id == current_user.id
    ).first()
    if not media:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Media not found")
    db.delete(media)
    db.commit()
    return {"detail": "Media deleted"}

===== END FILE: backend\routes\media_routes.py =====


===== START FILE: backend\routes\metrics_routes.py =====
from __future__ import annotations
from fastapi import APIRouter, Response
from prometheus_client import Counter, generate_latest, CONTENT_TYPE_LATEST

router = APIRouter(prefix="", tags=["metrics"])

ENQUEUES = Counter("laced_enqueues_total", "Total generation enqueues")
POLLS    = Counter("laced_polls_total", "Total status polls")

@router.get("/metrics")
def metrics():
    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)
===== END FILE: backend\routes\metrics_routes.py =====


===== START FILE: backend\routes\moderation_routes.py =====
from backend.controllers.moderation_controller import router as moderation_router


===== END FILE: backend\routes\moderation_routes.py =====


===== START FILE: backend\routes\motion_routes.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from backend.schemas.motion_schema import MotionCreate, MotionOut
from backend.services.motion_service import create_motion
from backend.models.base import get_db
from backend.dependencies.auth import get_current_user

router = APIRouter(prefix="/motion", tags=["motion"])

@router.post("/", response_model=MotionOut)
def create(data: MotionCreate, db: Session = Depends(get_db), user=Depends(get_current_user)):
    return create_motion(db, created_by=user.id, title=data.title, description=data.description, community_id=data.community_id, lounge_id=data.lounge_id)

===== END FILE: backend\routes\motion_routes.py =====


===== START FILE: backend\routes\post_routes.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from backend.schemas.post_schema import PostCreate, PostOut
from backend.services.post_service import create_post, list_posts
from backend.models.base import get_db
from backend.dependencies.auth import get_current_user

router = APIRouter(prefix="/post", tags=["post"])

@router.post("/", response_model=PostOut)
def create(data: PostCreate, db: Session = Depends(get_db), user=Depends(get_current_user)):
    return create_post(db, user_id=user.id, content=data.content, community_id=data.community_id, lounge_id=data.lounge_id, image_path=data.image_path)

@router.get("/", response_model=list[PostOut])
def list_all(community_id: int | None = None, lounge_id: int | None = None, limit: int = 50, offset: int = 0, db: Session = Depends(get_db)):
    return list_posts(db, community_id=community_id, lounge_id=lounge_id, limit=limit, offset=offset)

===== END FILE: backend\routes\post_routes.py =====


===== START FILE: backend\routes\premium_routes.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import List

from backend.db import get_db
from backend.schemas.tier_schema import TierCreate, TierUpdate, TierResponse
from backend.schemas.user_schema import UserResponse
from backend.controllers import premium_controller
from backend.dependencies.roles import require_role
from pydantic import BaseModel

router = APIRouter()

class AssignRequest(BaseModel):
    user_id: int
    tier_id: int

@router.post("/tiers", response_model=TierResponse, summary="Create a tier")
def create_tier(tier: TierCreate, db: Session = Depends(get_db), current_user=Depends(require_role("admin"))):
    return premium_controller.create_tier(tier, db)

@router.get("/tiers", response_model=List[TierResponse], summary="List all tiers")
def list_tiers(db: Session = Depends(get_db)):
    return premium_controller.list_tiers(db)

@router.put("/tiers/{tier_id}", response_model=TierResponse, summary="Update a tier")
def update_tier(tier_id: int, tier: TierUpdate, db: Session = Depends(get_db), current_user=Depends(require_role("admin"))):
    return premium_controller.update_tier(tier_id, tier, db)

@router.delete("/tiers/{tier_id}", summary="Delete a tier")
def delete_tier(tier_id: int, db: Session = Depends(get_db), current_user=Depends(require_role("admin"))):
    return premium_controller.delete_tier(tier_id, db)

# NEW: assign user to tier
@router.post("/assign", response_model=UserResponse, summary="Assign user to a tier")
def assign_user(request: AssignRequest, db: Session = Depends(get_db), current_user=Depends(require_role("admin"))):
    return premium_controller.assign_user(request.user_id, request.tier_id, db)

===== END FILE: backend\routes\premium_routes.py =====


===== START FILE: backend\routes\reaction_routes.py =====
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from backend.schemas.reaction_schema import ReactionCreate, ReactionOut
from backend.services.reaction_service import add_reaction_to_post, add_reaction_to_comment
from backend.models.base import get_db
from backend.dependencies.auth import get_current_user

router = APIRouter(prefix="/reaction", tags=["reaction"])

@router.post("/", response_model=ReactionOut)
def react(data: ReactionCreate, db: Session = Depends(get_db), user=Depends(get_current_user)):
    if data.target_type == "post":
        return add_reaction_to_post(db, user_id=user.id, post_id=data.target_id, rtype=data.type)
    elif data.target_type == "comment":
        return add_reaction_to_comment(db, user_id=user.id, comment_id=data.target_id, rtype=data.type)
    raise HTTPException(status_code=400, detail="Invalid target_type")

===== END FILE: backend\routes\reaction_routes.py =====


===== START FILE: backend\routes\report_routes.py =====
from backend.controllers.report_controller import router as report_router


===== END FILE: backend\routes\report_routes.py =====


===== START FILE: backend\routes\toggle_routes.py =====
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from backend.db import get_db
from backend.models.toggle import Toggle
from backend.schemas.toggle_schema import ToggleCreate, ToggleResponse
from backend.services import toggle_service

router = APIRouter()

@router.post("/", response_model=ToggleResponse, summary="Create toggle")
def create_toggle(toggle: ToggleCreate, db: Session = Depends(get_db)):
    db_toggle = toggle_service.create_toggle(db, toggle)
    return db_toggle

@router.get("/", response_model=list[ToggleResponse], summary="List toggles")
def list_toggles(db: Session = Depends(get_db)):
    return toggle_service.get_toggles(db)

===== END FILE: backend\routes\toggle_routes.py =====


===== START FILE: backend\routes\upload_routes.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import List
from backend.db import get_db
from backend.schemas.upload_schema import UploadCreate, UploadResponse
from backend.services import upload_service
from backend.dependencies.auth import get_current_user

router = APIRouter()

@router.post("/", response_model=UploadResponse)
def upload_file(upload: UploadCreate, db: Session = Depends(get_db), current_user=Depends(get_current_user)):
    return upload_service.create_upload(db, upload, current_user.id)

@router.get("/", response_model=List[UploadResponse])
def list_uploads(db: Session = Depends(get_db), current_user=Depends(get_current_user)):
    return upload_service.list_uploads(db)

===== END FILE: backend\routes\upload_routes.py =====


===== START FILE: backend\routes\user_routes.py =====
import os
from fastapi import APIRouter, Depends
from sqlalchemy import MetaData, Table, select, insert, update
from sqlalchemy.orm import Session
from secrets import token_urlsafe

from backend.db import get_db, engine

DEV_NO_AUTH = os.getenv("DEV_NO_AUTH", "0") == "1"

if DEV_NO_AUTH:
    class _DevUser: id = 1
    def get_current_user():
        return _DevUser()
else:
    from backend.core import auth
    get_current_user = auth.get_current_user

router = APIRouter(prefix="/user", tags=["user"])

def _users_table():
    md = MetaData()
    return Table("users", md, autoload_with=engine)

@router.get("/apikey")
def get_api_key(
    db: Session = Depends(get_db),
    current_user=Depends(get_current_user),
):
    users = _users_table()
    row = db.execute(
        select(users.c.id, users.c.api_key).where(users.c.id == current_user.id)
    ).fetchone()

    if row and row.api_key:
        return {"apikey": row.api_key}

    new_key = token_urlsafe(32)
    if row is None:
        try:
            db.execute(insert(users).values(id=current_user.id, api_key=new_key))
            db.commit()
            return {"apikey": new_key}
        except Exception:
            pass  # fall through to update trick

    db.execute(
        update(users).where(users.c.id == current_user.id).values(api_key=new_key)
    )
    db.commit()
    return {"apikey": new_key}

@router.post("/apikey/rotate")
def rotate_api_key(
    db: Session = Depends(get_db),
    current_user=Depends(get_current_user),
):
    users = _users_table()
    new_key = token_urlsafe(32)
    existing = db.execute(
        select(users.c.id).where(users.c.id == current_user.id)
    ).fetchone()
    if existing is None:
        try:
            db.execute(insert(users).values(id=current_user.id, api_key=new_key))
        except Exception:
            pass
    db.execute(
        update(users).where(users.c.id == current_user.id).values(api_key=new_key)
    )
    db.commit()
    return {"apikey": new_key}

===== END FILE: backend\routes\user_routes.py =====


===== START FILE: backend\routes\video_routes.py =====
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import List
from backend.db import get_db
from backend.schemas.video_schema import VideoCreate, VideoResponse
from backend.services import video_service
from backend.dependencies.auth import get_current_user

router = APIRouter()

@router.post("/", response_model=VideoResponse)
def upload_video(video: VideoCreate, db: Session = Depends(get_db), current_user=Depends(get_current_user)):
    return video_service.create_video(db, video, current_user.id)

@router.get("/", response_model=List[VideoResponse])
def list_videos(db: Session = Depends(get_db), current_user=Depends(get_current_user)):
    return video_service.list_videos(db)

===== END FILE: backend\routes\video_routes.py =====


===== START FILE: backend\routes\whisper_routes.py =====
from fastapi import APIRouter
from pydantic import BaseModel, Field

router = APIRouter(prefix="/whisper", tags=["whisper"])

class PromptIn(BaseModel):
    prompt: str = Field(..., min_length=1, max_length=4000)

@router.post("/prompt")
def send_prompt(payload: PromptIn):
    # Return a deterministic ack with required "reply" field for tests
    return {
        "status": "accepted",
        "prompt": payload.prompt,
        "reply": f"echo: {payload.prompt}"
    }

===== END FILE: backend\routes\whisper_routes.py =====


===== START FILE: backend\schemas\__init__.py =====
# package

===== END FILE: backend\schemas\__init__.py =====


===== START FILE: backend\schemas\analytics_schema.py =====
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class AnalyticsCreate(BaseModel):
    action: str
    details: Optional[str] = None

class AnalyticsResponse(BaseModel):
    id: int
    action: str
    details: Optional[str]
    timestamp: datetime

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\analytics_schema.py =====


===== START FILE: backend\schemas\auth_schema.py =====
from pydantic import BaseModel

class LoginRequest(BaseModel):
    username: str
    password: str

class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"

===== END FILE: backend\schemas\auth_schema.py =====


===== START FILE: backend\schemas\avatar_schema.py =====
from pydantic import BaseModel
from datetime import datetime

class AvatarCreate(BaseModel):
    image_url: str

class AvatarResponse(BaseModel):
    id: int
    image_url: str
    created_at: datetime

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\avatar_schema.py =====


===== START FILE: backend\schemas\comment_schema.py =====
from pydantic import BaseModel

class CommentCreate(BaseModel):
    post_id: int
    content: str

class CommentOut(BaseModel):
    id: int
    post_id: int
    user_id: int
    content: str
    class Config:
        from_attributes = True

===== END FILE: backend\schemas\comment_schema.py =====


===== START FILE: backend\schemas\community_schema.py =====
from pydantic import BaseModel
from typing import Optional, List

class CommunityCreate(BaseModel):
    name: str
    description: Optional[str] = None

class CommunityOut(BaseModel):
    id: int
    name: str
    description: Optional[str] = None
    owner_id: int
    class Config:
        from_attributes = True

===== END FILE: backend\schemas\community_schema.py =====


===== START FILE: backend\schemas\editor_schema.py =====
from __future__ import annotations
from pydantic import BaseModel, Field
from typing import Optional, List

class EditorDocumentCreate(BaseModel):
    title: str = Field(..., max_length=255)
    media_id: Optional[int] = None

class EditorDocumentOut(BaseModel):
    id: int
    owner_id: int
    title: str
    media_id: Optional[int] = None

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\editor_schema.py =====


===== START FILE: backend\schemas\enhancement_schema.py =====
from __future__ import annotations
from pydantic import BaseModel, Field
from typing import Optional, List

class EnhancementRequestCreate(BaseModel):
    prompt: str = Field(..., min_length=1)

class EnhancementRequestOut(BaseModel):
    id: int
    document_id: int
    requested_by: int
    prompt: str
    status: str

    class Config:
        from_attributes = True

class EnhancementVersionOut(BaseModel):
    id: int
    document_id: int
    parent_request_id: Optional[int] = None
    version_index: int
    url: Optional[str] = None
    notes: Optional[str] = None

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\enhancement_schema.py =====


===== START FILE: backend\schemas\feature_toggle_schema.py =====
from pydantic import BaseModel

class FeatureToggleBase(BaseModel):
    feature_name: str
    enabled: bool = False

class FeatureToggleCreate(FeatureToggleBase):
    pass

class FeatureToggleResponse(FeatureToggleBase):
    id: int
    class Config:
        from_attributes = True

===== END FILE: backend\schemas\feature_toggle_schema.py =====


===== START FILE: backend\schemas\history_schema.py =====
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class HistoryCreate(BaseModel):
    user_id: int
    action: str

class HistoryResponse(BaseModel):
    id: int
    user_id: int
    action: str
    timestamp: datetime

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\history_schema.py =====


===== START FILE: backend\schemas\invite_schema.py =====
from pydantic import BaseModel, EmailStr
from typing import Optional

class InviteCreate(BaseModel):
    invitee_email: EmailStr
    community_id: Optional[int] = None
    lounge_id: Optional[int] = None

class InviteAccept(BaseModel):
    token: str

class InviteOut(BaseModel):
    id: int
    inviter_id: int
    invitee_email: EmailStr
    token: str
    community_id: Optional[int] = None
    lounge_id: Optional[int] = None
    status: str
    class Config:
        from_attributes = True

===== END FILE: backend\schemas\invite_schema.py =====


===== START FILE: backend\schemas\lora_schema.py =====
from pydantic import BaseModel
from datetime import datetime

class LoRACreate(BaseModel):
    name: str
    path: str

class LoRAResponse(BaseModel):
    id: int
    name: str
    path: str
    uploaded_at: datetime

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\lora_schema.py =====


===== START FILE: backend\schemas\lounge_schema.py =====
from pydantic import BaseModel
from typing import Optional

class LoungeCreate(BaseModel):
    community_id: int
    name: str
    description: Optional[str] = None

class LoungeOut(BaseModel):
    id: int
    community_id: int
    name: str
    description: Optional[str] = None
    class Config:
        from_attributes = True

===== END FILE: backend\schemas\lounge_schema.py =====


===== START FILE: backend\schemas\media_schema.py =====
# backend/schemas/media_schema.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class MediaBase(BaseModel):
    file_url: str

class MediaCreate(MediaBase):
    pass

class MediaResponse(MediaBase):
    id: int
    uploaded_at: datetime
    user_id: Optional[int] = None

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\media_schema.py =====


===== START FILE: backend\schemas\metrics_schema.py =====
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class MetricsCreate(BaseModel):
    event_type: str
    value: Optional[str] = None

class MetricsResponse(BaseModel):
    id: int
    event_type: str
    value: Optional[str]
    timestamp: datetime

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\metrics_schema.py =====


===== START FILE: backend\schemas\moderation_schema.py =====
from __future__ import annotations
from typing import Optional, Dict, Any, List
from datetime import datetime
from pydantic import BaseModel

from backend.models.moderation import TargetType, ModerationStatus


class ModerationCreate(BaseModel):
    target_type: TargetType
    target_id: int
    reason: Optional[str] = None
    detected_labels: Optional[Dict[str, float]] = None
    is_nsfw: bool = False
    created_by_id: Optional[int] = None
    assigned_to_id: Optional[int] = None


class ModerationAssign(BaseModel):
    assigned_to_id: int


class ModerationUpdateStatus(BaseModel):
    status: ModerationStatus
    resolution_notes: Optional[str] = None
    is_nsfw: Optional[bool] = None


class ModerationResponse(BaseModel):
    id: int
    target_type: TargetType
    target_id: int
    status: ModerationStatus
    reason: Optional[str]
    detected_labels: Optional[Dict[str, float]]
    is_nsfw: bool
    created_by_id: Optional[int]
    assigned_to_id: Optional[int]
    resolution_notes: Optional[str]
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class ModerationListResponse(BaseModel):
    items: List[ModerationResponse]
    total: int

===== END FILE: backend\schemas\moderation_schema.py =====


===== START FILE: backend\schemas\motion_schema.py =====
from pydantic import BaseModel
from typing import Optional

class MotionCreate(BaseModel):
    title: str
    description: Optional[str] = None
    community_id: Optional[int] = None
    lounge_id: Optional[int] = None

class MotionOut(BaseModel):
    id: int
    title: str
    description: Optional[str] = None
    community_id: Optional[int] = None
    lounge_id: Optional[int] = None
    status: str
    created_by: int
    class Config:
        from_attributes = True

===== END FILE: backend\schemas\motion_schema.py =====


===== START FILE: backend\schemas\post_schema.py =====
from pydantic import BaseModel
from typing import Optional

class PostCreate(BaseModel):
    content: str
    community_id: Optional[int] = None
    lounge_id: Optional[int] = None
    image_path: Optional[str] = None

class PostOut(BaseModel):
    id: int
    user_id: int
    community_id: Optional[int] = None
    lounge_id: Optional[int] = None
    content: str
    image_path: Optional[str] = None
    class Config:
        from_attributes = True

===== END FILE: backend\schemas\post_schema.py =====


===== START FILE: backend\schemas\premium_schema.py =====
from pydantic import BaseModel
from typing import Optional

class PremiumModelBase(BaseModel):
    name: str
    description: Optional[str] = None

class PremiumModelCreate(PremiumModelBase):
    tier_id: int

class PremiumModelResponse(PremiumModelBase):
    id: int
    tier_id: int
    is_active: bool

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\premium_schema.py =====


===== START FILE: backend\schemas\reaction_schema.py =====
from pydantic import BaseModel
from typing import Literal, Optional

class ReactionCreate(BaseModel):
    target_type: Literal["post", "comment"]
    target_id: int
    type: str = "like"

class ReactionOut(BaseModel):
    id: int
    user_id: int
    post_id: Optional[int] = None
    comment_id: Optional[int] = None
    type: str
    class Config:
        from_attributes = True

===== END FILE: backend\schemas\reaction_schema.py =====


===== START FILE: backend\schemas\report_schema.py =====
from __future__ import annotations
from typing import Optional
from datetime import datetime
from pydantic import BaseModel

from backend.models.moderation import TargetType
from backend.models.report import ReportStatus, ReportReason


class ReportCreate(BaseModel):
    target_type: TargetType
    target_id: int
    reason: ReportReason
    details: Optional[str] = None


class ReportResponse(BaseModel):
    id: int
    reporter_id: Optional[int]
    target_type: TargetType
    target_id: int
    reason: ReportReason
    details: Optional[str]
    status: ReportStatus
    moderation_case_id: Optional[int]
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\report_schema.py =====


===== START FILE: backend\schemas\settings_schema.py =====
from pydantic import BaseModel

class UserSettingsResponse(BaseModel):
    id: int
    user_id: int
    tier_id: int
    notifications_enabled: bool

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\settings_schema.py =====


===== START FILE: backend\schemas\system_flag_schema.py =====
from pydantic import BaseModel

class SystemFlagBase(BaseModel):
    key: str
    value: bool = False

class SystemFlagCreate(SystemFlagBase):
    pass

class SystemFlagResponse(SystemFlagBase):
    id: int
    class Config:
        from_attributes = True

===== END FILE: backend\schemas\system_flag_schema.py =====


===== START FILE: backend\schemas\tier_schema.py =====
from pydantic import BaseModel
from typing import Optional


class TierBase(BaseModel):
    name: str
    description: Optional[str] = None
    price: float


class TierCreate(TierBase):
    pass


class TierUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    price: Optional[float] = None


class TierResponse(TierBase):
    id: int

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\tier_schema.py =====


===== START FILE: backend\schemas\toggle_schema.py =====
from pydantic import BaseModel

class ToggleBase(BaseModel):
    name: str
    enabled: bool = False

class ToggleCreate(ToggleBase):
    pass

class ToggleResponse(ToggleBase):
    id: int
    class Config:
        from_attributes = True

===== END FILE: backend\schemas\toggle_schema.py =====


===== START FILE: backend\schemas\token_schema.py =====
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str

===== END FILE: backend\schemas\token_schema.py =====


===== START FILE: backend\schemas\upload_schema.py =====
from pydantic import BaseModel
from datetime import datetime

class UploadCreate(BaseModel):
    filename: str
    file_url: str

class UploadResponse(BaseModel):
    id: int
    filename: str
    file_url: str
    uploaded_at: datetime

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\upload_schema.py =====


===== START FILE: backend\schemas\user_schema.py =====
from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime

# --- Tier sub-schema ---
class TierOut(BaseModel):
    id: int
    name: str
    description: Optional[str] = None
    price: float

    class Config:
        from_attributes = True

# --- User schemas ---
class UserBase(BaseModel):
    email: EmailStr
    username: str

class UserCreate(UserBase):
    password: str

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class UserResponse(UserBase):
    id: int
    role: str
    is_active: bool
    created_at: datetime
    tier: Optional[TierOut] = None   # ðŸ‘ˆ this exposes the relationship

    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str

class APIKeyResponse(BaseModel):
    api_key: str
    active: bool

===== END FILE: backend\schemas\user_schema.py =====


===== START FILE: backend\schemas\video_schema.py =====
from pydantic import BaseModel
from datetime import datetime

class VideoCreate(BaseModel):
    file_url: str

class VideoResponse(BaseModel):
    id: int
    file_url: str
    status: str
    created_at: datetime

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\video_schema.py =====


===== START FILE: backend\schemas\whisper_model_schema.py =====
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class WhisperPromptCreate(BaseModel):
    user_id: int
    prompt_text: str

class WhisperPromptResponse(BaseModel):
    id: int
    user_id: int
    prompt_text: str
    response_text: Optional[str] = None
    created_at: datetime

    class Config:
        from_attributes = True

===== END FILE: backend\schemas\whisper_model_schema.py =====


===== START FILE: backend\scripts\__init__.py =====
===== END FILE: backend\scripts\__init__.py =====


===== START FILE: backend\scripts\auth_diag_show_user.py =====
from __future__ import annotations
import os, sys, json
ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

def session():
    try:
        from backend.db import SessionLocal
        return SessionLocal()
    except Exception:
        from backend.db import engine
        from sqlalchemy.orm import sessionmaker
        return sessionmaker(bind=engine, autoflush=False, autocommit=False)()

def get_hash_verifier():
    try:
        from passlib.hash import bcrypt as pl_bcrypt
        def verify(p, h): 
            try: return pl_bcrypt.verify(p, h)
            except Exception: return False
        return "passlib.bcrypt", verify
    except Exception:
        pass
    try:
        import bcrypt
        def verify(p, h):
            try: return bcrypt.checkpw(p.encode("utf-8"), h.encode("utf-8"))
            except Exception: return False
        return "bcrypt", verify
    except Exception:
        pass
    return "none", lambda p,h: False

def show(email: str, password: str):
    from backend.models.user import User
    db = session()
    try:
        u = db.query(User).filter(User.email == email).first()
        if not u:
            print(json.dumps({"exists": False}))
            return
        fields = {}
        for k in ("hashed_password","password_hash","password","role","roles","username","api_key"):
            if hasattr(u, k):
                v = getattr(u, k)
                if isinstance(v, str):
                    fields[k] = (len(v), v[:8] + "..." if len(v)>8 else v)
                else:
                    fields[k] = str(v)
        which, verify = get_hash_verifier()
        hashed = None
        for name in ("hashed_password","password_hash","password"):
            if hasattr(u, name):
                hv = getattr(u, name)
                if isinstance(hv, str) and hv:
                    hashed = hv; used = name; break
        ok = verify(password, hashed) if hashed else False
        print(json.dumps({
            "exists": True,
            "id": getattr(u,"id",None),
            "email": getattr(u,"email",None),
            "password_field": used if hashed else None,
            "verifier": which,
            "verify_ok": ok,
            "fields": fields,
        }, default=str))
    finally:
        db.close()

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--email", required=True)
    ap.add_argument("--password", required=True)
    a = ap.parse_args()
    show(a.email, a.password)

===== END FILE: backend\scripts\auth_diag_show_user.py =====


===== START FILE: backend\scripts\batch_generate.py =====
import sys, json
from backend.tasks.generate import generate_image_task

def main(prompts):
    if not prompts:
        print("No prompts provided", file=sys.stderr)
        sys.exit(2)
    results = []
    for p in prompts:
        asyncres = generate_image_task.delay(p)
        results.append({"prompt": p, "task_id": asyncres.id})
    print(json.dumps({"queued": results}, indent=2))

if __name__ == "__main__":
    main(sys.argv[1:])
===== END FILE: backend\scripts\batch_generate.py =====


===== START FILE: backend\scripts\bootstrap_db.py =====
from backend.db import Base, engine, SessionLocal
from backend.models import *  # imports all models via backend/models/__init__.py
from passlib.hash import bcrypt

def ensure_tiers(db):
    from backend.models.tier import Tier
    names = {"Standard", "Premium"}
    existing = {t.name for t in db.query(Tier).all()}
    for name in names - existing:
        db.add(Tier(name=name))
    db.commit()

def ensure_default_user(db):
    from backend.models.user import User
    u = db.query(User).filter(User.email == "test@example.com").first()
    if not u:
        u = User(
            username="testuser",
            email="test@example.com",
            hashed_password=bcrypt.hash("password123"),
        )
        db.add(u)
        db.commit()

if __name__ == "__main__":
    # create all tables
    Base.metadata.create_all(bind=engine)
    db = SessionLocal()
    try:
        ensure_tiers(db)
        ensure_default_user(db)
        print("? DB bootstrap complete.")
    finally:
        db.close()

===== END FILE: backend\scripts\bootstrap_db.py =====


===== START FILE: backend\scripts\check_task.py =====
import sys, json
from celery.result import AsyncResult
from backend.celery_app import app

def main(task_id: str):
    r = AsyncResult(task_id, app=app)
    out = {
        "id": task_id,
        "ready": r.ready(),
        "successful": r.successful() if r.ready() else None,
        "status": r.status,
        "result": r.result if r.ready() else None,
    }
    print(json.dumps(out, indent=2, default=str))

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python -m backend.scripts.check_task <task_id>", file=sys.stderr)
        sys.exit(2)
    main(sys.argv[1])
===== END FILE: backend\scripts\check_task.py =====


===== START FILE: backend\scripts\create_admin.py =====
from __future__ import annotations
import os, sys, argparse

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

def get_session():
    try:
        from backend.db import SessionLocal  # preferred
        return SessionLocal()
    except Exception:
        from sqlalchemy.orm import sessionmaker
        from backend.db import engine
        return sessionmaker(bind=engine, autoflush=False, autocommit=False)()

def get_password_hash_fn():
    try:
        from backend.core import auth
        if hasattr(auth, "get_password_hash"):
            return auth.get_password_hash
    except Exception:
        pass
    raise RuntimeError("Missing password hasher (expected backend.core.auth.get_password_hash)")

def ensure_admin(email: str, password: str):
    from sqlalchemy import inspect
    from backend.dependencies.roles import UserRole

    db = get_session()
    try:
        # import User model
        try:
            from backend.models.user import User
        except Exception as e:
            raise RuntimeError(f"Could not import backend.models.user: {e}")

        # find existing
        user = db.query(User).filter(getattr(User, "email")==email).first()

        # create if missing
        if user is None:
            user = User()
            if hasattr(user, "email"):
                setattr(user, "email", email)
            if hasattr(user, "username") and not getattr(user, "username", None):
                setattr(user, "username", email.split("@")[0])
            if hasattr(user, "is_active"):
                setattr(user, "is_active", True)
            db.add(user)

        # set password (prefer hashed_password -> password_hash -> password)
        hasher = get_password_hash_fn()
        hashed = hasher(password)
        if hasattr(user, "hashed_password"):
            setattr(user, "hashed_password", hashed)
        elif hasattr(user, "password_hash"):
            setattr(user, "password_hash", hashed)
        elif hasattr(user, "password"):
            # if your model stores plaintext (not recommended) we still set hashed
            setattr(user, "password", hashed)
        else:
            raise RuntimeError("User model has no password field (expected hashed_password/password_hash/password)")

        # set role to admin
        if hasattr(user, "role"):
            setattr(user, "role", "admin")
        elif hasattr(user, "roles"):
            val = getattr(user, "roles")
            try:
                # support list/tuple/set
                seq = list(val) if isinstance(val, (list, tuple, set)) else []
            except Exception:
                seq = []
            if "admin" not in [str(x).lower() for x in seq]:
                seq.append("admin")
            setattr(user, "roles", seq)

        db.commit()
        db.refresh(user)
        return {"id": getattr(user, "id", None), "email": getattr(user, "email", None)}
    finally:
        db.close()

if __name__ == "__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("--email", required=True)
    ap.add_argument("--password", required=True)
    args = ap.parse_args()
    out = ensure_admin(args.email, args.password)
    print(out)

===== END FILE: backend\scripts\create_admin.py =====


===== START FILE: backend\scripts\create_or_promote_admin.py =====
from __future__ import annotations
import os, sys, argparse
ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

def get_session():
    try:
        from backend.db import SessionLocal
        return SessionLocal()
    except Exception:
        from sqlalchemy.orm import sessionmaker
        from backend.db import engine
        return sessionmaker(bind=engine, autoflush=False, autocommit=False)()

def find_user(db, email):
    from backend.models.user import User
    return db.query(User).filter(User.email == email).first()

def create_via_service(db, email: str, password: str):
    """
    Try several common user_service APIs so we reuse YOUR hashing:
      - user_service.register(db, email, password, **extras)
      - user_service.create_user(db, email, password, **extras)
      - user_service.create(db, email, password, **extras)
      - user_service.create_user_with_password(...)
    Returns user or None.
    """
    try:
        from backend.services import user_service
    except Exception:
        return None

    extras = {"is_active": True}
    funcs = [
        ("register", ("db","email","password")),
        ("create_user", ("db","email","password")),
        ("create", ("db","email","password")),
        ("create_user_with_password", ("db","email","password")),
    ]

    for name, _ in funcs:
        if hasattr(user_service, name):
            fn = getattr(user_service, name)
            try:
                # try common signatures
                user = fn(db=db, email=email, password=password, **extras)
                if user is None:
                    # some services return (user, token) or dict
                    continue
                return user
            except TypeError:
                # fallback with fewer kwargs
                try:
                    user = fn(db=db, email=email, password=password)
                    if user: return user
                except Exception:
                    pass
            except Exception:
                pass
    return None

def set_role_admin(db, user):
    # Works if your model has role (str) or roles (list)
    if hasattr(user, "role"):
        setattr(user, "role", "admin")
    if hasattr(user, "roles"):
        val = getattr(user, "roles")
        try:
            seq = list(val) if isinstance(val, (list, tuple, set)) else []
        except Exception:
            seq = []
        if "admin" not in [str(x).lower() for x in seq]:
            seq.append("admin")
        setattr(user, "roles", seq)
    db.add(user)

def upsert_admin(email: str, password: str):
    db = get_session()
    try:
        u = find_user(db, email)
        if u is None:
            # Create THROUGH your service to get correct hashing
            u = create_via_service(db, email, password)
            if u is None:
                # Final fallback: try a very generic model init path.
                from backend.models.user import User
                u = User(email=email, is_active=True)
                # We don't set password here — your auth won’t validate it without service/hasher.
                # This path is only to ensure row exists so you can fix via normal register later.
                db.add(u)
                db.flush()
        # Promote to admin
        set_role_admin(db, u)
        db.commit()
        db.refresh(u)
        return {"id": getattr(u, "id", None), "email": getattr(u, "email", None)}
    finally:
        db.close()

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--email", required=True)
    ap.add_argument("--password", required=True)
    args = ap.parse_args()
    print(upsert_admin(args.email, args.password))

===== END FILE: backend\scripts\create_or_promote_admin.py =====


===== START FILE: backend\scripts\db_who.py =====
from __future__ import annotations
import os, sys, json
sys.path.insert(0, r"D:\whisper-laced")
from sqlalchemy import text
from backend.db import engine, SessionLocal
info = {"engine_url": str(engine.url)}
if engine.url.get_backend_name() == "sqlite":
    info["sqlite_path"] = engine.url.database
db = SessionLocal()
try:
    users = db.execute(text("SELECT id, email FROM users ORDER BY id")).fetchall()
    info["users"] = [{"id": r[0], "email": r[1]} for r in users]
finally:
    db.close()
print(json.dumps(info))

===== END FILE: backend\scripts\db_who.py =====


===== START FILE: backend\scripts\export_assets.py =====
"""
Exports assets metadata (stub).
"""
import json, os

def main():
    out = os.path.normpath("D:/whisper-laced/backend/export_assets.json")
    with open(out, "w", encoding="utf-8") as f:
        json.dump({"assets": []}, f)
    print("exported:", out)

if __name__ == "__main__":
    main()

===== END FILE: backend\scripts\export_assets.py =====


===== START FILE: backend\scripts\fix_reports_table.py =====
import sqlite3, os, sys
p = r"D:\whisper-laced\backend\db.sqlite3"
con = sqlite3.connect(p)
cur = con.cursor()

# Make sure table exists (create minimal if someone nuked it)
cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='reports'")
if not cur.fetchone():
    cur.execute("""
        CREATE TABLE reports(
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          ref_id INTEGER,
          topic TEXT,
          reason TEXT,
          status TEXT DEFAULT 'open',
          created_at TEXT DEFAULT (datetime('now'))
        )
    """)

# Ensure columns
def has_col(name):
    cur.execute("PRAGMA table_info(reports)")
    return any(r[1] == name for r in cur.fetchall())

if not has_col("target_type"):
    # Add with default so NOT NULL won’t break old rows
    cur.execute("ALTER TABLE reports ADD COLUMN target_type TEXT NOT NULL DEFAULT 'generic'")
else:
    # Fill blanks and make sure nothing is NULL
    cur.execute("UPDATE reports SET target_type='generic' WHERE target_type IS NULL OR target_type=''")

# Optional: make sure other columns exist
for name, ddl in [
    ("topic","TEXT"),
    ("reason","TEXT"),
    ("ref_id","INTEGER"),
    ("status","TEXT"),
    ("created_at","TEXT")
]:
    if not has_col(name):
        cur.execute(f"ALTER TABLE reports ADD COLUMN {name} {ddl}")

con.commit()
print("OK: reports table patched.")
con.close()

===== END FILE: backend\scripts\fix_reports_table.py =====


===== START FILE: backend\scripts\force_create_user.py =====
from backend.db import SessionLocal, engine, Base
from backend.models.user import User
from backend.core import auth as core_auth

def main():
    Base.metadata.create_all(bind=engine)
    db = SessionLocal()
    try:
        email = "whisperandlaced@gmail.com"
        username = email  # ensure NOT NULL username gets a value

        # if already exists by email or username, just update password + flags
        q = db.query(User)
        u = None
        if hasattr(User, "email"):
            u = q.filter(User.email == email).first()
        if not u and hasattr(User, "username"):
            u = q.filter(User.username == username).first()

        if not u:
            u = User()
            if hasattr(u, "email"): u.email = email
            if hasattr(u, "username"): u.username = username
            db.add(u)

        # set password using our compat helper
        pwd = core_auth.get_password_hash("AandD03022022$")
        for f in ("password_hash","hashed_password","password"):
            if hasattr(u, f):
                setattr(u, f, pwd)
                break

        # set safe flags if present
        for k,v in (("is_active",True),("is_admin",True),("active",True),("admin",True),("verified",True)):
            if hasattr(u, k): setattr(u, k, v)

        db.commit()
        db.refresh(u)
        print(f"[force_create_user] OK id={getattr(u,'id',None)} email={getattr(u,'email',None)} username={getattr(u,'username',None)}")
    finally:
        db.close()

if __name__ == "__main__":
    main()

===== END FILE: backend\scripts\force_create_user.py =====


===== START FILE: backend\scripts\force_promote_all_roles.py =====
from __future__ import annotations
import os, sys, json
sys.path.insert(0, r"D:\whisper-laced")

from sqlalchemy import text
from backend.db import SessionLocal
from backend.models.user import User

EMAIL = "whisperandlaced@gmail.com"

def go():
    db = SessionLocal()
    try:
        u = db.query(User).filter(User.email==EMAIL).first()
        if not u:
            return {"ok": False, "error": "user not found"}

        changed = False
        # common fields various codebases check:
        if hasattr(u, "role") and getattr(u, "role") != "ADMIN":
            u.role = "ADMIN"; changed = True
        if hasattr(u, "roles"):
            # include upper + lower variants
            try:
                roles = list(u.roles or [])
            except Exception:
                roles = []
            wanted = {"ADMIN","MODERATOR","admin","moderator"}
            if isinstance(roles, (list, tuple, set)):
                have = set(str(r) for r in roles)
                miss = [r for r in wanted if r not in have]
                if miss:
                    try:
                        u.roles = list(have | set(miss))
                        changed = True
                    except Exception:
                        pass
        for flag in ("is_admin","is_staff","is_moderator","is_superuser"):
            if hasattr(u, flag) and not getattr(u, flag):
                try:
                    setattr(u, flag, True)
                    changed = True
                except Exception:
                    pass

        if changed:
            db.add(u); db.commit(); db.refresh(u)

        row = db.execute(text("SELECT * FROM users WHERE email=:e"), {"e": EMAIL}).mappings().first()
        return {"ok": True, "id": u.id, "email": EMAIL, "changed": changed, "row": dict(row) if row else None}
    finally:
        db.close()

if __name__ == "__main__":
    print(json.dumps(go()))

===== END FILE: backend\scripts\force_promote_all_roles.py =====


===== START FILE: backend\scripts\init_db.py =====
"""
Ensures minimum tables exist (idempotent).
"""
import os, sqlite3

def _path():
    url = os.environ.get("DATABASE_URL", "sqlite:///D:/whisper-laced/backend/db.sqlite3")
    if url.startswith("sqlite:///"):
        return os.path.normpath(url[len("sqlite:///"):])
    return os.path.normpath("D:/whisper-laced/backend/db.sqlite3")

def _ensure(con):
    cur = con.cursor()
    # reports
    cur.execute("""CREATE TABLE IF NOT EXISTS reports(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      reporter_id INTEGER,
      target_type TEXT NOT NULL,
      target_id INTEGER NOT NULL,
      reason TEXT NOT NULL,
      details TEXT,
      status TEXT NOT NULL DEFAULT 'open',
      moderation_case_id INTEGER,
      created_at TEXT DEFAULT (datetime('now')),
      updated_at TEXT DEFAULT (datetime('now')),
      ref_id INTEGER,
      topic TEXT
    )""")
    # editor
    cur.execute("""CREATE TABLE IF NOT EXISTS editor_documents(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      created_at TEXT DEFAULT (datetime('now'))
    )""")
    cur.execute("""CREATE TABLE IF NOT EXISTS editor_versions(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      doc_id INTEGER NOT NULL,
      version INTEGER NOT NULL,
      body TEXT NOT NULL,
      created_at TEXT DEFAULT (datetime('now')),
      UNIQUE(doc_id, version)
    )""")
    cur.execute("""CREATE TABLE IF NOT EXISTS enhancement_requests(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      doc_id INTEGER NOT NULL,
      instruction TEXT NOT NULL,
      created_at TEXT DEFAULT (datetime('now'))
    )""")
    con.commit()

def main():
    path = _path()
    os.makedirs(os.path.dirname(path), exist_ok=True)
    con = sqlite3.connect(path)
    try:
        _ensure(con)
        print("init_db: OK ->", path)
    finally:
        con.close()

if __name__ == "__main__":
    main()

===== END FILE: backend\scripts\init_db.py =====


===== START FILE: backend\scripts\mint_admin_token.py =====
from __future__ import annotations
import os, sys, json, datetime as dt
sys.path.insert(0, r"D:\whisper-laced")

EMAIL = "whisperandlaced@gmail.com"
UID   = "1"  # we just created id=1 above

claims = {
    "sub": UID,                    # user id
    "email": EMAIL,
    "role": "admin",
    "roles": ["admin", "moderator"],
    "scopes": ["admin"],           # for OAuth2 scopes-based guards
    "permissions": ["admin"],      # some apps check this
    "is_admin": True,
    "exp": dt.datetime.utcnow() + dt.timedelta(minutes=60),
}

def make_token(c):
    # prefer app's JWT function
    try:
        from backend.core import auth
        if hasattr(auth, "create_access_token"):
            return auth.create_access_token(c)
    except Exception:
        pass
    # fallback to jose/pyjwt with env secrets
    secret = os.getenv("SECRET_KEY", "dev-secret-change-me")
    alg    = os.getenv("ALGORITHM", "HS256")
    try:
        from jose import jwt as jj
        return jj.encode(c, secret, algorithm=alg)
    except Exception:
        import jwt as pj
        t = pj.encode(c, secret, algorithm=alg)
        return t.decode() if isinstance(t, bytes) else t

print(json.dumps({"access_token": make_token(claims)}))

===== END FILE: backend\scripts\mint_admin_token.py =====


===== START FILE: backend\scripts\mint_admin_upper_token.py =====
from __future__ import annotations
import os, sys, json, datetime as dt
sys.path.insert(0, r"D:\whisper-laced")

EMAIL = "whisperandlaced@gmail.com"
UID   = "1"  # from your upsert

claims = {
    "sub": UID,                     # id
    "email": EMAIL,
    "role": "ADMIN",
    "roles": ["ADMIN","MODERATOR"],
    "scope": "admin",               # some guards use single string "scope"
    "scopes": ["admin","moderation"],
    "permissions": ["ADMIN","MODERATOR"],
    "is_admin": True,
    "is_staff": True,
    "is_moderator": True,
    "is_superuser": True,
    "exp": dt.datetime.utcnow() + dt.timedelta(minutes=60),
}

def make_token(c):
    try:
        from backend.core import auth
        if hasattr(auth, "create_access_token"):
            return auth.create_access_token(c)
    except Exception:
        pass
    secret = os.getenv("SECRET_KEY","dev-secret-change-me")
    alg    = os.getenv("ALGORITHM","HS256")
    try:
        from jose import jwt as jj
        return jj.encode(c, secret, algorithm=alg)
    except Exception:
        import jwt as pj
        t = pj.encode(c, secret, algorithm=alg)
        return t.decode() if isinstance(t, bytes) else t

print(json.dumps({"access_token": make_token(claims)}))

===== END FILE: backend\scripts\mint_admin_upper_token.py =====


===== START FILE: backend\scripts\mint_token_for_user.py =====
from __future__ import annotations
import os, sys, json, datetime as dt
ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
if ROOT not in sys.path: sys.path.insert(0, ROOT)

def mint(user_id: str, email: str, role: str = "admin"):
    claims = {"sub": str(user_id), "email": email, "role": role, "roles": [role]}
    # Prefer your app's token creator
    try:
        from backend.core import auth
        if hasattr(auth, "create_access_token"):
            tok = auth.create_access_token(claims)
            print(json.dumps({"token": tok}))
            return
    except Exception:
        pass
    # Fallback: jose or pyjwt using env vars
    secret = os.getenv("SECRET_KEY", "dev-secret-change-me")
    alg    = os.getenv("ALGORITHM", "HS256")
    mins   = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "60"))
    payload = claims.copy()
    payload["exp"] = dt.datetime.utcnow() + dt.timedelta(minutes=mins)
    try:
        from jose import jwt as jose_jwt
        tok = jose_jwt.encode(payload, secret, algorithm=alg)
        print(json.dumps({"token": tok}))
        return
    except Exception:
        pass
    import jwt as pyjwt
    tok = pyjwt.encode(payload, secret, algorithm=alg)
    # PyJWT on some versions returns bytes; normalize to str
    if isinstance(tok, bytes):
        tok = tok.decode("utf-8")
    print(json.dumps({"token": tok}))

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--user_id", required=True)
    ap.add_argument("--email", required=True)
    ap.add_argument("--role", default="admin")
    a = ap.parse_args()
    mint(a.user_id, a.email, a.role)

===== END FILE: backend\scripts\mint_token_for_user.py =====


===== START FILE: backend\scripts\mint_two_tokens.py =====
from __future__ import annotations
import os, sys, json, datetime as dt
sys.path.insert(0, r"D:\whisper-laced")

def make_token(claims):
    # Prefer your project function
    try:
        from backend.core import auth
        if hasattr(auth, "create_access_token"):
            return auth.create_access_token(claims)
    except Exception:
        pass
    # Fallback to jose/pyjwt using app/env secrets
    secret = os.getenv("SECRET_KEY", "dev-secret-change-me")
    alg    = os.getenv("ALGORITHM", "HS256")
    try:
        from jose import jwt as jj
        return jj.encode(claims, secret, algorithm=alg)
    except Exception:
        import jwt as pj
        tok = pj.encode(claims, secret, algorithm=alg)
        return tok.decode() if isinstance(tok, bytes) else tok

uid = os.environ.get("UID")
email = os.environ.get("EMAIL")

base = {"role":"admin","roles":["admin"], "exp": dt.datetime.utcnow()+dt.timedelta(minutes=60)}
t1 = make_token(dict(sub=str(uid), email=email, **base))    # sub=id
t2 = make_token(dict(sub=email,     email=email, **base))    # sub=email
print(json.dumps({"sub_id": t1, "sub_email": t2}))

===== END FILE: backend\scripts\mint_two_tokens.py =====


===== START FILE: backend\scripts\print_users.py =====
from backend.db import SessionLocal, engine, Base
from backend.models.user import User
from sqlalchemy import inspect

def main():
    db = SessionLocal()
    try:
        insp = inspect(engine)
        print("[print_users] tables:", insp.get_table_names())
        cols = [c.name for c in User.__table__.columns]
        print("[print_users] User columns:", cols)

        users = db.query(User).all()
        print(f"[print_users] count: {len(users)}")
        for u in users:
            # print common identity fields if present
            bits = []
            for k in ("id", "email", "email_address", "username"):
                if hasattr(u, k):
                    bits.append(f"{k}={getattr(u,k)}")
            print("  -", ", ".join(bits) if bits else repr(u))
    finally:
        db.close()

if __name__ == "__main__":
    main()

===== END FILE: backend\scripts\print_users.py =====


===== START FILE: backend\scripts\promote_admin.py =====
from backend.db import SessionLocal, engine, Base
from backend.models.user import User

def main():
    Base.metadata.create_all(bind=engine)
    db = SessionLocal()
    try:
        u = db.query(User).filter(User.email=="whisperandlaced@gmail.com").first()
        if not u: 
            print("No user"); return
        for k in ("is_admin","admin"):
            if hasattr(u,k): setattr(u,k,True)
        db.commit(); db.refresh(u)
        print(f"Promoted: id={u.id} is_admin={getattr(u,'is_admin',None)} admin={getattr(u,'admin',None)}")
    finally:
        db.close()

if __name__=="__main__":
    main()

===== END FILE: backend\scripts\promote_admin.py =====


===== START FILE: backend\scripts\promote_admin_now.py =====
from __future__ import annotations
import argparse, sys
from backend.db import SessionLocal
from backend.models.user import User

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--email", required=True)
    args = ap.parse_args()

    db = SessionLocal()
    try:
        u = db.query(User).filter(User.email==args.email.lower()).first()
        if not u:
            print({"ok": False, "error": "user not found"}); return
        # ensure the flag exists; many schemas already have it
        if not hasattr(u, "is_admin"):
            print({"ok": False, "error": "user model missing is_admin"}) ; return
        u.is_admin = True
        # optional: populate role/roles if your model has them
        if hasattr(u, "role") and not getattr(u, "role"):
            u.role = "admin"
        if hasattr(u, "roles"):
            try:
                roles = set((u.roles or []))
                roles.add("admin")
                u.roles = list(roles)
            except Exception:
                pass
        db.add(u); db.commit(); db.refresh(u)
        print({"ok": True, "id": u.id, "email": u.email, "is_admin": getattr(u, "is_admin", None), "role": getattr(u, "role", None)})
    finally:
        db.close()

if __name__ == "__main__":
    main()

===== END FILE: backend\scripts\promote_admin_now.py =====


===== START FILE: backend\scripts\promote_admin_runtime.py =====
from __future__ import annotations
import os, sys, json
sys.path.insert(0, r"D:\whisper-laced")

from sqlalchemy import inspect, text
from backend.db import SessionLocal
from backend.models.user import User

EMAIL = "whisperandlaced@gmail.com"

def promote():
    db = SessionLocal()
    try:
        u = db.query(User).filter(User.email == EMAIL).first()
        if not u:
            return {"ok": False, "error": "User not found"}
        changed = False

        # set any/all role fields this model might have
        if hasattr(u, "role") and getattr(u, "role") != "admin":
            u.role = "admin"; changed = True
        if hasattr(u, "roles"):
            try:
                roles = list(u.roles or [])
            except Exception:
                roles = []
            low = [str(r).lower() for r in roles]
            if "admin" not in low:
                roles.append("admin")
                try:
                    u.roles = roles
                except Exception:
                    pass
                changed = True
        if hasattr(u, "is_admin") and not getattr(u, "is_admin"):
            try:
                u.is_admin = True
                changed = True
            except Exception:
                pass
        if hasattr(u, "is_moderator") and not getattr(u, "is_moderator"):
            try:
                u.is_moderator = True
                changed = True
            except Exception:
                pass

        if changed:
            db.add(u); db.commit(); db.refresh(u)

        # reflect DB columns + values for visibility
        insp = inspect(db.bind)
        cols = [c["name"] for c in db.execute(text("PRAGMA table_info(users)")).mappings()]
        row = db.execute(text("SELECT * FROM users WHERE email=:e"), {"e": EMAIL}).mappings().first()
        return {"ok": True, "id": u.id, "email": EMAIL, "changed": changed, "columns": cols, "row": dict(row) if row else None}
    finally:
        db.close()

if __name__ == "__main__":
    print(json.dumps(promote()))

===== END FILE: backend\scripts\promote_admin_runtime.py =====


===== START FILE: backend\scripts\provision_admin_smart.py =====
from __future__ import annotations
import os, sys, json

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

def session():
    try:
        from backend.db import SessionLocal
        return SessionLocal()
    except Exception:
        from backend.db import engine
        from sqlalchemy.orm import sessionmaker
        return sessionmaker(bind=engine, autoflush=False, autocommit=False)()

def promote_admin(db, u):
    changed = False
    if hasattr(u, "role"):
        if getattr(u, "role", None) != "admin":
            setattr(u, "role", "admin"); changed = True
    if hasattr(u, "roles"):
        try:
            seq = list(getattr(u, "roles"))
        except Exception:
            seq = []
        low = [str(x).lower() for x in seq]
        if "admin" not in low:
            seq.append("admin"); setattr(u, "roles", seq); changed = True
    if changed: db.add(u)
    return changed

def find_user(db, email):
    from backend.models.user import User
    return db.query(User).filter(User.email == email).first()

def try_import_user_schema():
    # Try common schema module names and class names
    schema_mod_candidates = [
        "backend.schemas.user_schema",
        "backend.schemas.users",
        "backend.schemas.user",
        "backend.schemas",
    ]
    class_candidates = ["UserCreate","UserInCreate","UserRegister","RegisterRequest","UserSignup","UserCreateSchema"]
    for mod in schema_mod_candidates:
        try:
            m = __import__(mod, fromlist=["*"])
        except Exception:
            continue
        for cls in class_candidates:
            t = getattr(m, cls, None)
            if t:
                return t, f"{mod}.{cls}"
    return None, None

def try_user_service_create(db, email, password):
    # Prefer service API so hashing matches your production code
    try:
        from backend.services import user_service
    except Exception as e:
        return None, f"user_service import failed: {e}"

    schema_type, schema_name = try_import_user_schema()
    obj_variants = []
    if schema_type:
        # Build schema instance with common fields
        for fields in (
            dict(email=email, password=password, is_active=True),
            dict(email=email, password=password),
            dict(username=email.split("@")[0], email=email, password=password, is_active=True),
            dict(username=email.split("@")[0], email=email, password=password),
        ):
            try:
                obj = schema_type(**fields)
                obj_variants.append(("schema", obj, fields))
            except Exception:
                pass

    # Also try plain dict payload
    obj_variants += [
        ("dict", dict(email=email, password=password, is_active=True), None),
        ("dict", dict(email=email, password=password), None),
    ]

    func_candidates = [
        "register",
        "create_user",
        "create",
        "create_user_with_password",
        "signup",
        "create_with_password",
    ]

    # Try function(obj=..., db=...), function(db=..., obj=...), function(db=..., email=..., password=...)
    for fname in func_candidates:
        fn = getattr(user_service, fname, None)
        if not fn:
            continue
        for kind, payload, raw in obj_variants:
            try:
                # try as obj argument name variants
                for argname in ("user_in","user","data","payload","schema"):
                    try:
                        u = fn(db=db, **{argname: payload})
                        if u: return u, f"user_service.{fname}({argname}=..., db=...) via {schema_name or kind}"
                    except TypeError:
                        continue
                # try named fields
                try:
                    u = fn(db=db, email=email, password=password)
                    if u: return u, f"user_service.{fname}(email,password) direct"
                except TypeError:
                    pass
            except Exception:
                continue
    return None, "no matching service create function worked"

def provision(email, password):
    db = session()
    try:
        u = find_user(db, email)
        created_via = None
        if u is None:
            u, created_via = try_user_service_create(db, email, password)
            if u is None:
                # Last resort: bare User(); won't set password (so token may still fail until you register properly)
                from backend.models.user import User
                u = User()
                if hasattr(u, "email"): setattr(u, "email", email)
                if hasattr(u, "username") and not getattr(u, "username", None):
                    setattr(u, "username", email.split("@")[0])
                if hasattr(u, "is_active"): setattr(u, "is_active", True)
                db.add(u); db.flush()
                created_via = "bare User() fallback (no password set)"
        changed = promote_admin(db, u)
        db.commit(); db.refresh(u)
        return {"id": getattr(u, "id", None), "email": getattr(u, "email", None), "created_via": created_via, "promoted": changed}
    finally:
        db.close()

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--email", required=True)
    ap.add_argument("--password", required=True)
    args = ap.parse_args()
    print(json.dumps(provision(args.email, args.password)))

===== END FILE: backend\scripts\provision_admin_smart.py =====


===== START FILE: backend\scripts\rebuild_db_and_admin.py =====
import sys
sys.path.insert(0, r"D:/whisper-laced")
from backend.db import engine, Base, SessionLocal
from backend.models.user import User
from backend.core.password import get_password_hash

# Create tables
Base.metadata.create_all(bind=engine)
print("✅ schema at", engine.url)

# Upsert admin
db = SessionLocal()
try:
    email = "whisperandlaced@gmail.com"
    pwd   = "AandD03022022$"
    u = db.query(User).filter(User.email==email).first()
    if not u:
        u = User(email=email, username="whisperandlaced")
        db.add(u); db.flush()
    u.hashed_password = get_password_hash(pwd)
    db.commit()
    print({"ok": True, "id": u.id, "email": u.email})
finally:
    db.close()

===== END FILE: backend\scripts\rebuild_db_and_admin.py =====


===== START FILE: backend\scripts\seed_db.py =====
"""
Seeds a couple of demo rows (idempotent-ish).
"""
import sqlite3, os

def _path():
    url = os.environ.get("DATABASE_URL", "sqlite:///D:/whisper-laced/backend/db.sqlite3")
    if url.startswith("sqlite:///"):
        return os.path.normpath(url[len("sqlite:///"):])
    return os.path.normpath("D:/whisper-laced/backend/db.sqlite3")

def main():
    p = _path()
    con = sqlite3.connect(p); con.row_factory = sqlite3.Row
    cur = con.cursor()
    # editor seed
    cur.execute("INSERT INTO editor_documents(title) VALUES(?)", ("Welcome Doc",))
    doc_id = cur.lastrowid
    cur.execute("INSERT INTO editor_versions(doc_id,version,body) VALUES(?,?,?)", (doc_id,1,"hello world"))
    con.commit()
    print("seed_db: OK -> doc", doc_id)

if __name__ == "__main__":
    main()

===== END FILE: backend\scripts\seed_db.py =====


===== START FILE: backend\scripts\seed_user.py =====
import argparse
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from backend.db import SessionLocal, engine, Base
from backend.core import auth as core_auth
from backend.models.user import User

PASSWORD_FIELDS = ("password_hash", "hashed_password", "password")

def set_password(user, plaintext: str):
    material = core_auth.get_password_hash(plaintext)
    for field in PASSWORD_FIELDS:
        if hasattr(user, field):
            setattr(user, field, material)
            return field
    setattr(user, "password_hash", material)
    return "password_hash"

def ensure_tables():
    try:
        Base.metadata.create_all(bind=engine)
    except Exception as e:
        print(f"[seed_user] WARN: create_all failed: {e}")

def upsert_user(email: str, password: str, is_admin: bool):
    ensure_tables()
    db: Session = SessionLocal()
    try:
        user = db.query(User).filter(User.email == email).first()
        created = False
        if not user:
            user = User(email=email)
            created = True

        field_used = set_password(user, password)

        for attr, val in [
            ("is_active", True),
            ("is_admin", is_admin),
            ("active", True),
            ("admin", is_admin),
            ("verified", True),
        ]:
            if hasattr(user, attr):
                setattr(user, attr, val)

        if created:
            db.add(user)
        db.commit()
        db.refresh(user)
        return created, field_used
    except IntegrityError:
        db.rollback()
        user = db.query(User).filter(User.email == email).first()
        return False, "unknown"
    finally:
        db.close()

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--email", required=True)
    p.add_argument("--password", required=True)
    p.add_argument("--admin", action="store_true")
    args = p.parse_args()
    created, field = upsert_user(args.email, args.password, args.admin)
    print(f"[seed_user] {'CREATED' if created else 'UPDATED'} {args.email} (password -> {field})")

if __name__ == "__main__":
    main()

===== END FILE: backend\scripts\seed_user.py =====


===== START FILE: backend\scripts\sign_file.py =====
import sys, os
from backend.security.signer import sign
def main(name: str, exp: int = 600):
    qs = sign(f"/files/{name}", exp)
    base = os.getenv("PUBLIC_BASE", "http://127.0.0.1:5000")
    print(f"{base}/files/{name}?{qs}")
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python -m backend.scripts.sign_file <filename> [exp_seconds]", file=sys.stderr); sys.exit(2)
    main(sys.argv[1], int(sys.argv[2]) if len(sys.argv) > 2 else 600)
===== END FILE: backend\scripts\sign_file.py =====


===== START FILE: backend\scripts\training_tracker.py =====
"""
Appends a training run record to CSV.
"""
import csv, time, os

def main():
    out = os.path.normpath("D:/whisper-laced/backend/training_runs.csv")
    new = not os.path.exists(out)
    with open(out, "a", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        if new:
            w.writerow(["ts","run_id","status","notes"])
        w.writerow([int(time.time()), os.urandom(4).hex(), "ok", "seed run"])
    print("tracked:", out)

if __name__ == "__main__":
    main()

===== END FILE: backend\scripts\training_tracker.py =====


===== START FILE: backend\scripts\upsert_admin_bcrypt.py =====
from __future__ import annotations
import os, sys
ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

def session():
    try:
        from backend.db import SessionLocal
        return SessionLocal()
    except Exception:
        from backend.db import engine
        from sqlalchemy.orm import sessionmaker
        return sessionmaker(bind=engine, autoflush=False, autocommit=False)()

def bcrypt_hash(pw: str) -> str:
    try:
        from passlib.hash import bcrypt
        return bcrypt.hash(pw)
    except Exception:
        pass
    try:
        import bcrypt as _b
        return _b.hashpw(pw.encode("utf-8"), _b.gensalt()).decode("utf-8")
    except Exception as e:
        raise RuntimeError("Install a hasher: pip install 'passlib[bcrypt]' OR pip install bcrypt") from e

def upsert_admin(email: str, password: str):
    from backend.models.user import User
    db = session()
    try:
        u = db.query(User).filter(User.email == email).first()
        hashed = bcrypt_hash(password)

        if u is None:
            # Build a new instance WITHOUT flushing until hashed is set
            u = User()
            # minimal required fields first
            if hasattr(u, "email"): setattr(u, "email", email)
            if hasattr(u, "username") and not getattr(u, "username", None):
                setattr(u, "username", email.split("@")[0])
            # set the *required* password column BEFORE any flush
            set_pw = False
            for field in ("hashed_password", "password_hash", "password"):
                if hasattr(u, field):
                    setattr(u, field, hashed)
                    set_pw = True
                    break
            if not set_pw:
                raise RuntimeError("User model has no password column among: hashed_password/password_hash/password")

            # set role(s) to admin if present
            if hasattr(u, "role"):
                setattr(u, "role", "admin")
            if hasattr(u, "roles"):
                try:
                    seq = list(getattr(u, "roles"))
                except Exception:
                    seq = []
                if "admin" not in [str(x).lower() for x in seq]:
                    seq.append("admin")
                    setattr(u, "roles", seq)

            db.add(u)
            # now safe to flush/commit
            db.commit()
            db.refresh(u)
        else:
            # Existing user: ensure password and admin role
            updated = False
            pw_field = None
            for field in ("hashed_password", "password_hash", "password"):
                if hasattr(u, field):
                    pw_field = field
                    break
            if pw_field:
                if not getattr(u, pw_field, None):
                    setattr(u, pw_field, hashed)
                    updated = True
            # role promotion
            if hasattr(u, "role") and getattr(u, "role", None) != "admin":
                setattr(u, "role", "admin"); updated = True
            if hasattr(u, "roles"):
                try:
                    seq = list(getattr(u, "roles"))
                except Exception:
                    seq = []
                if "admin" not in [str(x).lower() for x in seq]:
                    seq.append("admin")
                    setattr(u, "roles", seq)
                    updated = True
            if updated:
                db.add(u)
                db.commit()
                db.refresh(u)

        print({"id": getattr(u, "id", None), "email": getattr(u, "email", None)})
    finally:
        db.close()

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--email", required=True)
    ap.add_argument("--password", required=True)
    args = ap.parse_args()
    upsert_admin(args.email, args.password)

===== END FILE: backend\scripts\upsert_admin_bcrypt.py =====


===== START FILE: backend\scripts\upsert_admin_here.py =====
#!/usr/bin/env python
import sys
sys.path.insert(0, r"D:\whisper-laced")

from backend.db import SessionLocal, engine, Base
from backend.models.user import User
from backend.core.password import get_password_hash

def main(email: str, password: str):
    # ensure tables exist
    Base.metadata.create_all(bind=engine)

    db = SessionLocal()
    try:
        u = db.query(User).filter(User.email == email).first()
        if not u:
            u = User(email=email, username=email.split("@")[0])
            db.add(u)
        # use pbkdf2_sha256 from backend.core.password
        u.hashed_password = get_password_hash(password)
        db.commit()
        db.refresh(u)
        print({"id": u.id, "email": u.email})
    finally:
        db.close()

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--email", required=True)
    ap.add_argument("--password", required=True)
    args = ap.parse_args()
    main(args.email, args.password)

===== END FILE: backend\scripts\upsert_admin_here.py =====


===== START FILE: backend\security\auth.py =====
from __future__ import annotations
import os
from fastapi import Depends, HTTPException
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from starlette.status import HTTP_401_UNAUTHORIZED

# If BEARER_TOKEN is unset/empty, auth is disabled (allow all).
_BEARER = os.getenv("BEARER_TOKEN", "").strip()
_scheme = HTTPBearer(auto_error=False)

def auth_bearer(creds: HTTPAuthorizationCredentials = Depends(_scheme)) -> None:
    if not _BEARER:  # auth disabled
        return
    if creds is None or creds.scheme.lower() != "bearer" or creds.credentials != _BEARER:
        raise HTTPException(status_code=HTTP_401_UNAUTHORIZED, detail="Unauthorized")
===== END FILE: backend\security\auth.py =====


===== START FILE: backend\security\signer.py =====
from __future__ import annotations
import base64, hashlib, hmac, time, os
from urllib.parse import urlencode, quote

_SECRET = os.getenv("SECRET_KEY", "CHANGE_ME").encode("utf-8")

def sign(path: str, exp_seconds: int = 600) -> str:
    """Return a query string 'exp=..&sig=..' for path (no host), exp offset seconds."""
    exp = int(time.time()) + int(exp_seconds)
    msg = f"{path}?exp={exp}".encode("utf-8")
    sig = hmac.new(_SECRET, msg, hashlib.sha256).digest()
    return urlencode({"exp": exp, "sig": base64.urlsafe_b64encode(sig).decode().rstrip("=")})

def verify(path: str, exp: int, sig_b64: str) -> bool:
    if exp < int(time.time()):
        return False
    msg = f"{path}?exp={exp}".encode("utf-8")
    raw = base64.urlsafe_b64decode(sig_b64 + "===")
    expect = hmac.new(_SECRET, msg, hashlib.sha256).digest()
    return hmac.compare_digest(raw, expect)
===== END FILE: backend\security\signer.py =====


===== START FILE: backend\seed_dev.py =====
import os, sys
ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

from sqlalchemy.orm import Session
from backend.db import SessionLocal, Base, engine
# ensure models are imported
import backend.models  # noqa
from backend.models.tier import Tier
from backend.models.user import User

Base.metadata.create_all(bind=engine)
db: Session = SessionLocal()

tier = db.query(Tier).filter_by(name="Standard").first()
if not tier:
    tier = Tier(name="Standard", description="Dev seed")
    db.add(tier)
    db.commit()
    db.refresh(tier)

user = db.get(User, 1)
if not user:
    # Minimal fields; adjust if your model requires more
    user = User(id=1)
    try:
        setattr(user, "email", "dev@example.com")
    except Exception:
        pass
    try:
        setattr(user, "username", "dev")
    except Exception:
        pass
    setattr(user, "tier_id", getattr(tier, "id", None))
    db.add(user)
    db.commit()
    db.refresh(user)

print("Seeded: tier id =", tier.id, "user id =", user.id)

===== END FILE: backend\seed_dev.py =====


===== START FILE: backend\services\__init__.py =====
# package

===== END FILE: backend\services\__init__.py =====


===== START FILE: backend\services\analytics_service.py =====
from sqlalchemy.orm import Session
from backend.models.analytics import Analytics
from backend.schemas.analytics_schema import AnalyticsCreate

def create_analytics(db: Session, data: AnalyticsCreate):
    analytics = Analytics(**data.dict())
    db.add(analytics)
    db.commit()
    db.refresh(analytics)
    return analytics

===== END FILE: backend\services\analytics_service.py =====


===== START FILE: backend\services\auth_service.py =====
from __future__ import annotations
from sqlalchemy.orm import Session
from sqlalchemy import select, or_
from backend.models.user import User
from backend.core.password import verify_password

def get_user_by_email_or_username(db: Session, login: str) -> User | None:
    stmt = select(User).where(or_(User.email == login, User.username == login))
    return db.execute(stmt).scalar_one_or_none()

def authenticate_user(db: Session, login: str, password: str) -> User | None:
    user = get_user_by_email_or_username(db, login)
    if not user or not user.hashed_password:
        return None
    if not verify_password(password, user.hashed_password):
        return None
    return user

===== END FILE: backend\services\auth_service.py =====


===== START FILE: backend\services\avatar_service.py =====
from sqlalchemy.orm import Session
from backend.models.avatar import Avatar
from backend.schemas.avatar_schema import AvatarCreate

def create_avatar(db: Session, avatar: AvatarCreate, user_id: int):
    db_avatar = Avatar(image_url=avatar.image_url, user_id=user_id)
    db.add(db_avatar)
    db.commit()
    db.refresh(db_avatar)
    return db_avatar

def list_avatars(db: Session):
    return db.query(Avatar).all()

===== END FILE: backend\services\avatar_service.py =====


===== START FILE: backend\services\comment_service.py =====
from sqlalchemy.orm import Session
from typing import List
from backend.models.comment import Comment

def create_comment(db: Session, user_id: int, post_id: int, content: str) -> Comment:
    c = Comment(user_id=user_id, post_id=post_id, content=content)
    db.add(c)
    db.commit()
    db.refresh(c)
    return c

def list_comments(db: Session, post_id: int) -> List[Comment]:
    return db.query(Comment).filter(Comment.post_id == post_id).all()

===== END FILE: backend\services\comment_service.py =====


===== START FILE: backend\services\community_service.py =====
from sqlalchemy.orm import Session
from typing import List
from backend.models.community import Community, community_members
from backend.models.user import User

def create_community(db: Session, owner_id: int, name: str, description: str | None) -> Community:
    c = Community(owner_id=owner_id, name=name, description=description)
    db.add(c)
    db.commit()
    db.refresh(c)
    # owner auto-joins
    db.execute(community_members.insert().values(community_id=c.id, user_id=owner_id))
    db.commit()
    return c

def add_member(db: Session, community_id: int, user_id: int) -> None:
    db.execute(community_members.insert().values(community_id=community_id, user_id=user_id))
    db.commit()

def list_communities(db: Session) -> List[Community]:
    return db.query(Community).all()

===== END FILE: backend\services\community_service.py =====


===== START FILE: backend\services\editor_service.py =====
from __future__ import annotations
from sqlalchemy.orm import Session
from sqlalchemy import select, func
from typing import List, Optional
from backend.models.editor import EditorDocument, EnhancementVersion

def create_document(db: Session, owner_id: int, title: str, media_id: int | None) -> EditorDocument:
    doc = EditorDocument(owner_id=owner_id, title=title, media_id=media_id)
    db.add(doc)
    db.flush()
    # initial version 1 (optional)
    v = EnhancementVersion(document_id=doc.id, version_index=1, notes="Initial")
    db.add(v)
    db.commit()
    db.refresh(doc)
    return doc

def list_documents(db: Session, owner_id: int, limit: int = 50, offset: int = 0) -> list[EditorDocument]:
    q = db.execute(select(EditorDocument).where(EditorDocument.owner_id == owner_id).order_by(EditorDocument.id.desc()).limit(limit).offset(offset))
    return [r[0] for r in q.all()]

def get_document(db: Session, doc_id: int, owner_id: int) -> Optional[EditorDocument]:
    q = db.execute(select(EditorDocument).where(EditorDocument.id == doc_id, EditorDocument.owner_id == owner_id))
    row = q.first()
    return row[0] if row else None

def next_version_index(db: Session, doc_id: int) -> int:
    q = db.execute(select(func.max(EnhancementVersion.version_index)).where(EnhancementVersion.document_id == doc_id))
    maxv = q.scalar()
    return (maxv or 0) + 1

def save_version(db: Session, doc_id: int, request_id: int | None, url: str | None, notes: str | None) -> EnhancementVersion:
    v = EnhancementVersion(
        document_id=doc_id,
        parent_request_id=request_id,
        version_index=next_version_index(db, doc_id),
        url=url,
        notes=notes,
    )
    db.add(v)
    db.commit()
    db.refresh(v)
    return v

def list_versions(db: Session, doc_id: int) -> list[EnhancementVersion]:
    q = db.execute(select(EnhancementVersion).where(EnhancementVersion.document_id == doc_id).order_by(EnhancementVersion.version_index.asc()))
    return [r[0] for r in q.all()]

===== END FILE: backend\services\editor_service.py =====


===== START FILE: backend\services\enhancement_service.py =====
from __future__ import annotations
from sqlalchemy.orm import Session
from sqlalchemy import select
from typing import Optional
from backend.models.editor import EnhancementRequest
from backend.services.editor_service import save_version

def create_request(db: Session, document_id: int, requested_by: int, prompt: str) -> EnhancementRequest:
    r = EnhancementRequest(document_id=document_id, requested_by=requested_by, prompt=prompt, status="queued")
    db.add(r)
    db.flush()
    return r

def process_request_immediate(db: Session, req: EnhancementRequest) -> EnhancementRequest:
    # Simulate enhancement done: create a new version with simple note
    req.status = "done"
    v = save_version(db, doc_id=req.document_id, request_id=req.id, url=None, notes=f"Enhanced: {req.prompt}")
    db.commit()
    return req

===== END FILE: backend\services\enhancement_service.py =====


===== START FILE: backend\services\history_service.py =====
from sqlalchemy.orm import Session
from backend.models.history import History
from backend.schemas.history_schema import HistoryCreate

def create_history(db: Session, data: HistoryCreate):
    history = History(**data.dict())
    db.add(history)
    db.commit()
    db.refresh(history)
    return history

def get_user_history(db: Session, user_id: int):
    return db.query(History).filter(History.user_id == user_id).all()

===== END FILE: backend\services\history_service.py =====


===== START FILE: backend\services\invite_service.py =====
import secrets
from datetime import datetime, timezone
from sqlalchemy.orm import Session
from backend.models.invite import Invite, InviteStatus

def create_invite(db: Session, inviter_id: int, invitee_email: str, community_id: int | None, lounge_id: int | None) -> Invite:
    token = secrets.token_urlsafe(24)
    inv = Invite(inviter_id=inviter_id, invitee_email=invitee_email, token=token, community_id=community_id, lounge_id=lounge_id)
    db.add(inv)
    db.commit()
    db.refresh(inv)
    return inv

def accept_invite(db: Session, token: str) -> Invite | None:
    inv = db.query(Invite).filter(Invite.token == token, Invite.status == InviteStatus.pending).first()
    if not inv:
        return None
    inv.status = InviteStatus.accepted
    inv.accepted_at = datetime.now(timezone.utc)
    db.add(inv)
    db.commit()
    db.refresh(inv)
    return inv

===== END FILE: backend\services\invite_service.py =====


===== START FILE: backend\services\lora_service.py =====
from sqlalchemy.orm import Session
from backend.models.lora import LoRA
from backend.schemas.lora_schema import LoRACreate

def create_lora(db: Session, lora_data: LoRACreate, user_id: int) -> LoRA:
    lora = LoRA(**lora_data.dict(), user_id=user_id)
    db.add(lora)
    db.commit()
    db.refresh(lora)
    return lora

def list_loras(db: Session, user_id: int):
    return db.query(LoRA).filter(LoRA.user_id == user_id).all()

===== END FILE: backend\services\lora_service.py =====


===== START FILE: backend\services\lounge_service.py =====
from sqlalchemy.orm import Session
from typing import List
from backend.models.lounge import Lounge, lounge_members

def create_lounge(db: Session, community_id: int, name: str, description: str | None) -> Lounge:
    l = Lounge(community_id=community_id, name=name, description=description)
    db.add(l)
    db.commit()
    db.refresh(l)
    return l

def add_member(db: Session, lounge_id: int, user_id: int) -> None:
    db.execute(lounge_members.insert().values(lounge_id=lounge_id, user_id=user_id))
    db.commit()

def list_lounges(db: Session, community_id: int | None = None) -> List[Lounge]:
    q = db.query(Lounge)
    if community_id:
        q = q.filter(Lounge.community_id == community_id)
    return q.all()

===== END FILE: backend\services\lounge_service.py =====


===== START FILE: backend\services\media_service.py =====
from sqlalchemy.orm import Session
from backend.models.media import Media

def create_media(db: Session, type: str, url: str, user_id: int):
    db_media = Media(type=type, url=url, user_id=user_id)
    db.add(db_media)
    db.commit()
    db.refresh(db_media)
    return db_media

def list_media(db: Session):
    return db.query(Media).all()

===== END FILE: backend\services\media_service.py =====


===== START FILE: backend\services\metrics_service.py =====
from sqlalchemy.orm import Session
from backend.models.metrics import Metrics
from backend.schemas.metrics_schema import MetricsCreate

def create_metric(db: Session, data: MetricsCreate):
    metric = Metrics(**data.dict())
    db.add(metric)
    db.commit()
    db.refresh(metric)
    return metric

===== END FILE: backend\services\metrics_service.py =====


===== START FILE: backend\services\moderation_service.py =====
from __future__ import annotations

from typing import Optional, List, Tuple, Dict
from sqlalchemy.orm import Session

from backend.models.moderation import ModerationCase, ModerationStatus, TargetType
from backend.models.report import ReportStatus


def create_case(
    db: Session,
    *,
    target_type: TargetType,
    target_id: int,
    reason: Optional[str] = None,
    detected_labels: Optional[Dict[str, float]] = None,
    is_nsfw: bool = False,
    created_by_id: Optional[int] = None,
    assigned_to_id: Optional[int] = None,
) -> ModerationCase:
    case = ModerationCase(
        target_type=target_type,
        target_id=target_id,
        reason=reason,
        detected_labels=detected_labels,
        is_nsfw=is_nsfw,
        created_by_id=created_by_id,
        assigned_to_id=assigned_to_id,
        status=ModerationStatus.pending,
    )
    db.add(case)
    db.commit()
    db.refresh(case)
    return case


def list_cases(
    db: Session,
    *,
    status: Optional[ModerationStatus] = None,
    target_type: Optional[TargetType] = None,
    assignee_id: Optional[int] = None,
    limit: int = 50,
    offset: int = 0,
) -> Tuple[List[ModerationCase], int]:
    q = db.query(ModerationCase)
    if status:
        q = q.filter(ModerationCase.status == status)
    if target_type:
        q = q.filter(ModerationCase.target_type == target_type)
    if assignee_id:
        q = q.filter(ModerationCase.assigned_to_id == assignee_id)
    total = q.count()
    items = (
        q.order_by(ModerationCase.created_at.desc())
        .offset(offset)
        .limit(limit)
        .all()
    )
    return items, total


def get_case(db: Session, case_id: int) -> Optional[ModerationCase]:
    return db.query(ModerationCase).filter(ModerationCase.id == case_id).first()


def assign_case(db: Session, case_id: int, user_id: int) -> ModerationCase:
    case = get_case(db, case_id)
    if not case:
        raise ValueError("Moderation case not found")
    case.assigned_to_id = user_id
    db.commit()
    db.refresh(case)
    return case


def update_status(
    db: Session,
    case_id: int,
    status: ModerationStatus,
    resolution_notes: Optional[str] = None,
    is_nsfw: Optional[bool] = None,
) -> ModerationCase:
    case = get_case(db, case_id)
    if not case:
        raise ValueError("Moderation case not found")

    case.status = status
    if resolution_notes is not None:
        case.resolution_notes = resolution_notes
    if is_nsfw is not None:
        case.is_nsfw = is_nsfw

    if status in (ModerationStatus.approved, ModerationStatus.rejected):
        for r in case.reports:
            if r.status != ReportStatus.closed:
                r.status = ReportStatus.closed

    db.commit()
    db.refresh(case)
    return case

===== END FILE: backend\services\moderation_service.py =====


===== START FILE: backend\services\motion_service.py =====
from sqlalchemy.orm import Session
from backend.models.motion import Motion

def create_motion(db: Session, created_by: int, title: str, description: str | None, community_id: int | None, lounge_id: int | None) -> Motion:
    m = Motion(created_by=created_by, title=title, description=description, community_id=community_id, lounge_id=lounge_id)
    db.add(m)
    db.commit()
    db.refresh(m)
    return m

===== END FILE: backend\services\motion_service.py =====


===== START FILE: backend\services\notify_service.py =====
from typing import Optional
from backend.tasks.notifications import notify_user_task

def notify_user(user_id: int, message: str, eager: bool = False) -> dict:
    if eager:
        return notify_user_task.apply(args=[user_id, message]).get()
    else:
        async_result = notify_user_task.delay(user_id, message)
        return {"task_id": async_result.id, "queued": True}

===== END FILE: backend\services\notify_service.py =====


===== START FILE: backend\services\post_service.py =====
from sqlalchemy.orm import Session
from typing import List
from backend.models.post import Post

def create_post(db: Session, user_id: int, content: str, community_id: int | None, lounge_id: int | None, image_path: str | None) -> Post:
    post = Post(user_id=user_id, content=content, community_id=community_id, lounge_id=lounge_id, image_path=image_path)
    db.add(post)
    db.commit()
    db.refresh(post)
    return post

def list_posts(db: Session, community_id: int | None = None, lounge_id: int | None = None, limit: int = 50, offset: int = 0) -> List[Post]:
    q = db.query(Post).order_by(Post.created_at.desc())
    if community_id:
        q = q.filter(Post.community_id == community_id)
    if lounge_id:
        q = q.filter(Post.lounge_id == lounge_id)
    return q.offset(offset).limit(limit).all()

===== END FILE: backend\services\post_service.py =====


===== START FILE: backend\services\premium_service.py =====
from sqlalchemy.orm import Session
from backend.models.tier import Tier
from backend.models.user import User
from backend.schemas.tier_schema import TierCreate, TierUpdate
from typing import List, Optional

def create_tier(db: Session, tier: TierCreate) -> Tier:
    db_tier = Tier(**tier.dict())
    db.add(db_tier)
    db.commit()
    db.refresh(db_tier)
    return db_tier

def list_tiers(db: Session) -> List[Tier]:
    return db.query(Tier).all()

def update_tier(db: Session, tier_id: int, tier: TierUpdate) -> Optional[Tier]:
    db_tier = db.query(Tier).filter(Tier.id == tier_id).first()
    if not db_tier:
        return None
    for key, value in tier.dict(exclude_unset=True).items():
        setattr(db_tier, key, value)
    db.commit()
    db.refresh(db_tier)
    return db_tier

def delete_tier(db: Session, tier_id: int) -> bool:
    db_tier = db.query(Tier).filter(Tier.id == tier_id).first()
    if not db_tier:
        return False
    db.delete(db_tier)
    db.commit()
    return True

# NEW: assign user to tier
def assign_user_to_tier(db: Session, user_id: int, tier_id: int) -> Optional[User]:
    user = db.query(User).filter(User.id == user_id).first()
    tier = db.query(Tier).filter(Tier.id == tier_id).first()
    if not user or not tier:
        return None
    user.tier_id = tier_id
    db.commit()
    db.refresh(user)
    return user

===== END FILE: backend\services\premium_service.py =====


===== START FILE: backend\services\reaction_service.py =====
from sqlalchemy.orm import Session
from backend.models.reaction import Reaction, ReactionType

def add_reaction_to_post(db: Session, user_id: int, post_id: int, rtype: str) -> Reaction:
    # toggle if exists
    existing = db.query(Reaction).filter(Reaction.user_id==user_id, Reaction.post_id==post_id).first()
    if existing:
        db.delete(existing)
        db.commit()
    r = Reaction(user_id=user_id, post_id=post_id, type=ReactionType(rtype))
    db.add(r)
    db.commit()
    db.refresh(r)
    return r

def add_reaction_to_comment(db: Session, user_id: int, comment_id: int, rtype: str) -> Reaction:
    existing = db.query(Reaction).filter(Reaction.user_id==user_id, Reaction.comment_id==comment_id).first()
    if existing:
        db.delete(existing)
        db.commit()
    r = Reaction(user_id=user_id, comment_id=comment_id, type=ReactionType(rtype))
    db.add(r)
    db.commit()
    db.refresh(r)
    return r

===== END FILE: backend\services\reaction_service.py =====


===== START FILE: backend\services\report_service.py =====
from typing import Any, Dict, List
from sqlalchemy.orm import Session

def _ensure_reports_schema(db: Session) -> None:
    # Works even if the table exists with fewer/different columns
    conn = db.connection().connection  # SQLAlchemy -> sqlite3 connection
    cur = conn.cursor()
    cur.execute("PRAGMA table_info(reports)")
    cols = {row[1] for row in cur.fetchall()}

    # If table missing entirely, create it
    if not cols:
        cur.execute("""
            CREATE TABLE reports(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ref_id INTEGER,
                topic TEXT,
                reason TEXT,
                status TEXT DEFAULT 'open',
                created_at TEXT DEFAULT (datetime('now'))
            )
        """)
        conn.commit()
        return

    # Add any missing columns
    desired = {
        "ref_id": "INTEGER",
        "topic": "TEXT",
        "reason": "TEXT",
        "status": "TEXT",
        "created_at": "TEXT"
    }
    for name, ddl in desired.items():
        if name not in cols:
            cur.execute(f"ALTER TABLE reports ADD COLUMN {name} {ddl}")
    conn.commit()

def create_report(db: Session, payload: Dict[str, Any]) -> Dict[str, Any]:
    _ensure_reports_schema(db)
    conn = db.connection().connection
    cur = conn.cursor()
    topic  = payload.get("topic")
    reason = payload.get("reason")
    ref_id = payload.get("ref_id")
    cur.execute(
        "INSERT INTO reports(topic, reason, ref_id, status, created_at) VALUES(?,?,?,?,datetime('now'))",
        (topic, reason, ref_id, "open")
    )
    conn.commit()
    rid = cur.lastrowid
    cur.execute("SELECT id, topic, reason, ref_id, status, created_at FROM reports WHERE id=?", (rid,))
    row = cur.fetchone()
    return {
        "id": row[0], "topic": row[1], "reason": row[2],
        "ref_id": row[3], "status": row[4], "created_at": row[5]
    }

def list_reports(db: Session, limit: int = 50, offset: int = 0) -> List[Dict[str, Any]]:
    _ensure_reports_schema(db)
    conn = db.connection().connection
    cur = conn.cursor()
    cur.execute(
        "SELECT id, topic, reason, ref_id, status, created_at FROM reports ORDER BY id DESC LIMIT ? OFFSET ?",
        (limit, offset)
    )
    return [
        {"id": r[0], "topic": r[1], "reason": r[2], "ref_id": r[3], "status": r[4], "created_at": r[5]}
        for r in cur.fetchall()
    ]

def close_report(db: Session, report_id: int) -> Dict[str, Any]:
    _ensure_reports_schema(db)
    conn = db.connection().connection
    cur = conn.cursor()
    cur.execute("UPDATE reports SET status='closed' WHERE id=?", (report_id,))
    conn.commit()
    cur.execute("SELECT id, topic, reason, ref_id, status, created_at FROM reports WHERE id=?", (report_id,))
    row = cur.fetchone()
    if not row:
        return {"id": report_id, "status": "closed"}
    return {
        "id": row[0], "topic": row[1], "reason": row[2],
        "ref_id": row[3], "status": row[4], "created_at": row[5]
    }

===== END FILE: backend\services\report_service.py =====


===== START FILE: backend\services\toggle_service.py =====
from sqlalchemy.orm import Session
from backend.models.toggle import Toggle
from backend.models.feature_toggle import FeatureToggle
from backend.models.system_flag import SystemFlag
from backend.schemas.toggle_schema import ToggleCreate
from backend.schemas.feature_toggle_schema import FeatureToggleCreate
from backend.schemas.system_flag_schema import SystemFlagCreate

# --- Generic Toggle ---
def create_toggle(db: Session, toggle: ToggleCreate) -> Toggle:
    db_toggle = Toggle(name=toggle.name, enabled=toggle.enabled)
    db.add(db_toggle)
    db.commit()
    db.refresh(db_toggle)
    return db_toggle

def get_toggles(db: Session):
    return db.query(Toggle).all()

# --- Feature Toggles ---
def create_feature_toggle(db: Session, feature: FeatureToggleCreate) -> FeatureToggle:
    db_feature = FeatureToggle(feature_name=feature.feature_name, enabled=feature.enabled)
    db.add(db_feature)
    db.commit()
    db.refresh(db_feature)
    return db_feature

def get_feature_toggles(db: Session):
    return db.query(FeatureToggle).all()

# --- System Flags ---
def create_system_flag(db: Session, flag: SystemFlagCreate) -> SystemFlag:
    db_flag = SystemFlag(key=flag.key, value=flag.value)
    db.add(db_flag)
    db.commit()
    db.refresh(db_flag)
    return db_flag

def get_system_flags(db: Session):
    return db.query(SystemFlag).all()

===== END FILE: backend\services\toggle_service.py =====


===== START FILE: backend\services\upload_service.py =====
from sqlalchemy.orm import Session
from backend.models.upload import Upload
from backend.schemas.upload_schema import UploadCreate

def create_upload(db: Session, upload: UploadCreate, user_id: int):
    db_upload = Upload(filename=upload.filename, file_url=upload.file_url, user_id=user_id)
    db.add(db_upload)
    db.commit()
    db.refresh(db_upload)
    return db_upload

def list_uploads(db: Session):
    return db.query(Upload).all()

===== END FILE: backend\services\upload_service.py =====


===== START FILE: backend\services\user_service.py =====
from sqlalchemy.orm import Session, joinedload
from passlib.context import CryptContext
from backend.models.user import User
from backend.db import SessionLocal
from backend.schemas.user_schema import UserCreate
import secrets

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain: str, hashed: str) -> bool:
    return pwd_context.verify(plain, hashed)

def create_user(db: Session, user: UserCreate) -> User:
    db_user = User(
        email=user.email,
        username=user.username,
        hashed_password=get_password_hash(user.password),
        role="user",
        api_key=secrets.token_hex(16),
        api_key_active=True,
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def authenticate_user(db: Session, email: str, password: str) -> User | None:
    user = db.query(User).filter(User.email == email).first()
    if not user or not verify_password(password, user.hashed_password):
        return None
    return user

def get_user_by_email(db: Session, email: str):
    return db.query(User).filter(User.email == email).first()

def get_user_by_id(db: Session, user_id: int):
    return db.query(User).options(joinedload(User.tier)).filter(User.id == user_id).first()

def get_or_create_api_key(user: User) -> str:
    if not user.api_key:
        db = SessionLocal()
        user_in_db = db.query(User).filter(User.id == user.id).first()
        user_in_db.api_key = secrets.token_urlsafe(32)
        db.commit()
        db.refresh(user_in_db)
        db.close()
        return user_in_db.api_key
    return user.api_key

===== END FILE: backend\services\user_service.py =====


===== START FILE: backend\services\video_service.py =====
from sqlalchemy.orm import Session
from backend.models.video import Video
from backend.schemas.video_schema import VideoCreate

def create_video(db: Session, video: VideoCreate, user_id: int):
    db_video = Video(file_url=video.file_url, user_id=user_id)
    db.add(db_video)
    db.commit()
    db.refresh(db_video)
    return db_video

def list_videos(db: Session):
    return db.query(Video).all()

===== END FILE: backend\services\video_service.py =====


===== START FILE: backend\services\whisper_service.py =====
from sqlalchemy.orm import Session
from typing import List
from backend.models.whisper_model import WhisperPrompt
from backend.schemas.whisper_model_schema import WhisperPromptCreate


def create_prompt_entry(db: Session, prompt_data: WhisperPromptCreate) -> WhisperPrompt:
    prompt = WhisperPrompt(**prompt_data.dict())
    db.add(prompt)
    db.commit()
    db.refresh(prompt)
    return prompt


def get_prompts_by_user(db: Session, user_id: int) -> List[WhisperPrompt]:
    return db.query(WhisperPrompt).filter(WhisperPrompt.user_id == user_id).order_by(WhisperPrompt.created_at.desc()).all()

===== END FILE: backend\services\whisper_service.py =====


===== START FILE: backend\tasks\__init__.py =====
===== END FILE: backend\tasks\__init__.py =====


===== START FILE: backend\tasks\generate.py =====
from __future__ import annotations
from datetime import datetime, timezone
from typing import Any, Dict, Optional
import os, json, time, uuid
from pathlib import Path

from backend.celery_app import app
from backend.config import settings

# Optional HTTP client; only needed if GENERATOR_MODE=http
try:
    import requests  # type: ignore
except Exception:
    requests = None  # we will guard usage

OUTPUT_DIR = Path(settings.OUTPUT_DIR)
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

def _safe_name(s: str) -> str:
    return "".join(c for c in s if c.isalnum() or c in ("-", "_", ".", " ")).strip()

def _write_json(p: Path, payload: Dict[str, Any]) -> None:
    p.parent.mkdir(parents=True, exist_ok=True)
    with p.open("w", encoding="utf-8") as f:
        json.dump(payload, f, indent=2, ensure_ascii=False)

def _local_pipeline(prompt: str, *, task_id: str, **kwargs: Any) -> Path:
    """Replace this with your real local generator; returns file path."""
    # Simulate real work â€” swap for actual generator call
    time.sleep(0.5)
    out = OUTPUT_DIR / f"{task_id}.json"
    _write_json(out, {"task_id": task_id, "prompt": prompt, "note": "replace with real image path"})
    return out

def _http_pipeline(prompt: str, *, task_id: str, **kwargs: Any) -> Path:
    if requests is None:
        raise RuntimeError("requests not installed but GENERATOR_MODE=http")
    url = settings.GENERATOR_HTTP_URL
    payload = {"task_id": task_id, "prompt": prompt, "params": kwargs}
    resp = requests.post(url, json=payload, timeout=settings.GENERATOR_HTTP_TIMEOUT)
    resp.raise_for_status()
    data = resp.json()

    # Expect either an explicit output_path or a downloadable URL
    output_path: Optional[str] = data.get("output_path")
    download_url: Optional[str] = data.get("url")

    if output_path:
        return Path(output_path)

    if download_url:
        # Save downloaded content to OUTPUT_DIR/<task_id>.png
        bin_resp = requests.get(download_url, timeout=settings.GENERATOR_HTTP_TIMEOUT)
        bin_resp.raise_for_status()
        ext = ".png"
        out = OUTPUT_DIR / f"{task_id}{ext}"
        with out.open("wb") as f:
            f.write(bin_resp.content)
        return out

    # As a last resort, persist whatever data we got
    fallback = OUTPUT_DIR / f"{task_id}.json"
    _write_json(fallback, {"task_id": task_id, "prompt": prompt, "raw": data})
    return fallback

@app.task(name="generate.image", bind=True, autoretry_for=(Exception,), retry_backoff=True, retry_kwargs={"max_retries": 3})
def generate_image_task(self, prompt: str, **kwargs: Any) -> Dict[str, Any]:
    """
    Production-ready wrapper around your generator.
    Switch behavior via GENERATOR_MODE env var: 'http' or 'local'.
    """
    task_id = self.request.id or str(uuid.uuid4())
    started_at = datetime.now(timezone.utc).isoformat()

    mode = settings.GENERATOR_MODE.lower().strip()
    if mode == "http":
        out_path = _http_pipeline(prompt, task_id=task_id, **kwargs)
    elif mode == "local":
        out_path = _local_pipeline(prompt, task_id=task_id, **kwargs)
    else:
        raise RuntimeError(f"Unsupported GENERATOR_MODE={settings.GENERATOR_MODE}")

    result = {
        "task_id": task_id,
        "prompt": prompt,
        "status": "completed",
        "started_at": started_at,
        "completed_at": datetime.now(timezone.utc).isoformat(),
        "output_path": str(out_path),
        "params": kwargs,
        "mode": mode,
    }
    return result

__all__ = ["generate_image_task"]
===== END FILE: backend\tasks\generate.py =====


===== START FILE: backend\tasks\moderation_tasks.py =====
from __future__ import annotations

from typing import Dict
from sqlalchemy.orm import Session

from backend.models.moderation import ModerationCase, ModerationStatus
from backend.services import moderation_service


BLOCK_LABELS = {"explicit_nudity", "sexual_activity", "child_safety", "graphic_violence"}


def run_moderation_scan(db: Session, case_id: int) -> ModerationCase:
    case = moderation_service.get_case(db, case_id)
    if not case:
        raise ValueError("Moderation case not found")

    labels: Dict[str, float] = case.detected_labels or {}
    trigger_hits = {k for k, v in labels.items() if k in BLOCK_LABELS and float(v) >= 0.80}

    if trigger_hits:
        case.status = ModerationStatus.escalated
        case.is_nsfw = True
        case.resolution_notes = (case.resolution_notes or "") + f" Auto-escalated by rules; hits={','.join(sorted(trigger_hits))}."
    elif labels:
        case.status = ModerationStatus.pending
    else:
        case.status = ModerationStatus.approved
        case.is_nsfw = False

    db.commit()
    db.refresh(case)
    return case

===== END FILE: backend\tasks\moderation_tasks.py =====


===== START FILE: backend\tasks\notifications.py =====
from backend.celery_app import celery

@celery.task(name="notify.user")
def notify_user_task(user_id: int, message: str) -> dict:
    # Stub: integrate real email/sms/push later
    return {"status": "queued", "user_id": user_id, "message": message}

===== END FILE: backend\tasks\notifications.py =====


===== START FILE: backend\tests\__init__.py =====
===== END FILE: backend\tests\__init__.py =====


===== START FILE: backend\tests\test_phase8_apikey.py =====
# tests/test_phase8_apikey.py
from types import SimpleNamespace

from fastapi.testclient import TestClient
from sqlalchemy import MetaData, Table, insert
from sqlalchemy.exc import IntegrityError

from backend.app.main import app
from backend.db import engine, SessionLocal

# Override auth dependency to return a stable user id=1 for tests only
try:
    from backend.core import auth
except Exception as e:
    raise RuntimeError(f"Auth module import failed: {e}")

app.dependency_overrides[auth.get_current_user] = lambda: SimpleNamespace(id=1)

def ensure_user_row():
    md = MetaData()
    users = Table("users", md, autoload_with=engine)
    with SessionLocal() as db:
        # Insert row id=1 if missing; ignore if other columns are NOT NULL
        try:
            db.execute(insert(users).values(id=1))
            db.commit()
        except IntegrityError:
            db.rollback()  # row exists or NOT NULL constraint tripped â€” that's fine

def test_get_apikey_creates_or_returns_key():
    ensure_user_row()
    client = TestClient(app)
    r = client.get("/user/apikey")
    assert r.status_code == 200, r.text
    data = r.json()
    assert "apikey" in data and isinstance(data["apikey"], str) and len(data["apikey"]) >= 20

def test_rotate_apikey_changes_key():
    ensure_user_row()
    client = TestClient(app)
    r1 = client.get("/user/apikey")
    assert r1.status_code == 200
    old_key = r1.json()["apikey"]

    r2 = client.post("/user/apikey/rotate")
    assert r2.status_code == 200
    new_key = r2.json()["apikey"]

    assert new_key and new_key != old_key

===== END FILE: backend\tests\test_phase8_apikey.py =====


===== START FILE: backend\tests\test_schema_imports.py =====
from pathlib import Path
import importlib
import sys

# Ensure backend root is on sys.path
sys.path.append(str(Path(__file__).resolve().parent.parent))

def test_all_schema_imports():
    schemas_path = Path(__file__).resolve().parent.parent / "schemas"
    schema_files = [f.stem for f in schemas_path.glob("*.py") if f.name != "__init__.py"]

    for schema in schema_files:
        try:
            # FIX: use backend.schemas instead of schemas
            importlib.import_module(f"backend.schemas.{schema}")
            print(f"? Successfully imported: {schema}")
        except Exception as e:
            print(f"? Failed to import {schema}: {e}")

if __name__ == "__main__":
    test_all_schema_imports()

===== END FILE: backend\tests\test_schema_imports.py =====


===== START FILE: backend\tests\test_whisper_prompt.py =====
import requests

def test_send_prompt():
    url = "http://localhost:5000/whisper/prompt"
    payload = {"prompt": "hello whisper"}
    headers = {"Content-Type": "application/json"}

    response = requests.post(url, json=payload, headers=headers)

    assert response.status_code == 200, f"Unexpected status code: {response.status_code}"
    data = response.json()
    assert "reply" in data, "Missing reply in response"
    print("âœ… Prompt test passed:", data)

if __name__ == "__main__":
    test_send_prompt()

===== END FILE: backend\tests\test_whisper_prompt.py =====


===== START FILE: backend\utils\formatter.py =====
def to_snake(s: str) -> str:
    import re
    s = re.sub(r"([A-Z]+)", r"_\1", s).lower()
    return s.strip("_")

===== END FILE: backend\utils\formatter.py =====


===== START FILE: backend\utils\logger.py =====
import logging, json, sys, os

class JsonFormatter(logging.Formatter):
    def format(self, record):
        base = {
            "level": record.levelname.lower(),
            "msg": record.getMessage(),
            "logger": record.name,
        }
        if hasattr(record, "request_id"):
            base["request_id"] = record.request_id
        return json.dumps(base)

def setup_logging():
    root = logging.getLogger()
    if not root.handlers:
        h = logging.StreamHandler(sys.stdout)
        h.setFormatter(JsonFormatter())
        root.addHandler(h)
    root.setLevel(os.environ.get("LOG_LEVEL", "INFO").upper())

def get_logger(name: str = "app"):
    setup_logging()
    return logging.getLogger(name)

===== END FILE: backend\utils\logger.py =====


===== START FILE: backend\utils\response.py =====
from fastapi import Response
import json

def json_ok(payload, status: int = 200) -> Response:
    return Response(content=json.dumps(payload), media_type="application/json", status_code=status)

def json_err(message: str, status: int = 400) -> Response:
    return Response(content=json.dumps({"detail": message}), media_type="application/json", status_code=status)

===== END FILE: backend\utils\response.py =====


===== START FILE: backend\utils\validators.py =====
from typing import Optional

def non_empty_str(v: Optional[str]) -> str:
    if not v or not v.strip():
        raise ValueError("must be non-empty")
    return v.strip()

===== END FILE: backend\utils\validators.py =====


===== START FILE: docker-compose.yml =====
version: "3.9"
services:
  redis:
    image: redis:7
    ports:
      - "6379:6379"

  api:
    build: .
    environment:
      DATABASE_URL: "sqlite:///data/db.sqlite3"
      SECRET_KEY: "${SECRET_KEY}"
      CELERY_BROKER_URL: "redis://redis:6379/0"
      CELERY_RESULT_BACKEND: "redis://redis:6379/0"
    volumes:
      - ./backend:/app/backend
      - ./scripts:/app/scripts
      - data:/data
    ports:
      - "5000:5000"
    depends_on:
      - redis

  worker:
    build: .
    command: ["celery","-A","backend.celery_app","worker","-P","solo","-l","info"]
    environment:
      DATABASE_URL: "sqlite:///data/db.sqlite3"
      SECRET_KEY: "${SECRET_KEY}"
      CELERY_BROKER_URL: "redis://redis:6379/0"
      CELERY_RESULT_BACKEND: "redis://redis:6379/0"
    volumes:
      - ./backend:/app/backend
      - ./scripts:/app/scripts
      - data:/data
    depends_on:
      - redis

volumes:
  data:

===== END FILE: docker-compose.yml =====


===== START FILE: ops\start-api.ps1 =====
$env:PYTHONPATH            = 'D:\whisper-laced'
$env:CELERY_BROKER_URL     = 'redis://127.0.0.1:6379/0'
$env:CELERY_RESULT_BACKEND = 'redis://127.0.0.1:6379/1'
$env:BEARER_TOKEN          = 'SUPER_SECRET_TOKEN_123'
Set-Location 'D:\whisper-laced'
& 'D:\whisper-laced\venv\Scripts\python.exe' -m uvicorn backend.app.main:app --host 127.0.0.1 --port 5000

===== END FILE: ops\start-api.ps1 =====


===== START FILE: ops\start-worker.ps1 =====
$env:PYTHONPATH            = 'D:\whisper-laced'
$env:CELERY_BROKER_URL     = 'redis://127.0.0.1:6379/0'
$env:CELERY_RESULT_BACKEND = 'redis://127.0.0.1:6379/1'
$env:GENERATOR_MODE        = 'local'
Set-Location 'D:\whisper-laced'
& 'D:\whisper-laced\venv\Scripts\python.exe' -m celery -A backend.celery_app worker -P solo -l info -Q celery -n "worker1@$env:COMPUTERNAME"

===== END FILE: ops\start-worker.ps1 =====


===== START FILE: outputs\images\29340ebf-975e-44c7-b376-a635f6c73552.json =====
{
  "task_id": "29340ebf-975e-44c7-b376-a635f6c73552",
  "prompt": "silver ring on velvet",
  "note": "replace with real image path"
}
===== END FILE: outputs\images\29340ebf-975e-44c7-b376-a635f6c73552.json =====


===== START FILE: outputs\images\2add18ce-8f92-4135-8707-e1f135d09f4f.json =====
{
  "task_id": "2add18ce-8f92-4135-8707-e1f135d09f4f",
  "prompt": "silver ring on velvet",
  "note": "replace with real image path"
}
===== END FILE: outputs\images\2add18ce-8f92-4135-8707-e1f135d09f4f.json =====


===== START FILE: outputs\images\393f739c-06b8-423c-84b8-157a5ae15774.json =====
{
  "task_id": "393f739c-06b8-423c-84b8-157a5ae15774",
  "prompt": "silver ring on velvet",
  "note": "replace with real image path"
}
===== END FILE: outputs\images\393f739c-06b8-423c-84b8-157a5ae15774.json =====


===== START FILE: outputs\images\46189bd6-7fe2-4d77-a695-9f103e7ae18f.json =====
{
  "task_id": "46189bd6-7fe2-4d77-a695-9f103e7ae18f",
  "prompt": "silver ring on velvet",
  "note": "replace with real image path"
}
===== END FILE: outputs\images\46189bd6-7fe2-4d77-a695-9f103e7ae18f.json =====


===== START FILE: outputs\images\56aa0c37-33c5-4acd-8973-cda987f90ea2.json =====
{
  "task_id": "56aa0c37-33c5-4acd-8973-cda987f90ea2",
  "prompt": "silver ring on velvet",
  "note": "replace with real image path"
}
===== END FILE: outputs\images\56aa0c37-33c5-4acd-8973-cda987f90ea2.json =====


===== START FILE: outputs\images\681dee9e-95d7-4986-a690-0a33fa916e1b.json =====
{
  "task_id": "681dee9e-95d7-4986-a690-0a33fa916e1b",
  "prompt": "silver ring on velvet",
  "note": "replace with real image path"
}
===== END FILE: outputs\images\681dee9e-95d7-4986-a690-0a33fa916e1b.json =====


===== START FILE: outputs\images\79f1c0fc-a99b-4f8c-b639-99ddede743ec.json =====
{
  "task_id": "79f1c0fc-a99b-4f8c-b639-99ddede743ec",
  "prompt": "silver ring on velvet",
  "note": "replace with real image path"
}
===== END FILE: outputs\images\79f1c0fc-a99b-4f8c-b639-99ddede743ec.json =====


===== START FILE: outputs\images\81124865-244f-4533-8511-ee3f070d18bd.json =====
{
  "task_id": "81124865-244f-4533-8511-ee3f070d18bd",
  "prompt": "silver ring on velvet",
  "note": "replace with real image path"
}
===== END FILE: outputs\images\81124865-244f-4533-8511-ee3f070d18bd.json =====


===== START FILE: outputs\images\8a1a912e-ee3f-4a37-bc63-bdecfaf10cc5.json =====
{
  "task_id": "8a1a912e-ee3f-4a37-bc63-bdecfaf10cc5",
  "prompt": "silver ring on velvet",
  "note": "replace with real image path"
}
===== END FILE: outputs\images\8a1a912e-ee3f-4a37-bc63-bdecfaf10cc5.json =====


===== START FILE: outputs\images\8cfea661-1bd5-4b51-8433-76d0a4d1925f.json =====
{
  "task_id": "8cfea661-1bd5-4b51-8433-76d0a4d1925f",
  "prompt": "silver ring on velvet",
  "note": "replace with real image path"
}
===== END FILE: outputs\images\8cfea661-1bd5-4b51-8433-76d0a4d1925f.json =====


===== START FILE: outputs\images\c00f5894-783f-48c7-9c8c-1b8885398871.json =====
{
  "task_id": "c00f5894-783f-48c7-9c8c-1b8885398871",
  "prompt": "silver ring on velvet",
  "note": "replace with real image path"
}
===== END FILE: outputs\images\c00f5894-783f-48c7-9c8c-1b8885398871.json =====


===== START FILE: outputs\images\de145740-dd58-4a2b-95b6-dff738f318a9.json =====
{
  "task_id": "de145740-dd58-4a2b-95b6-dff738f318a9",
  "prompt": "rose perfume bottle",
  "generated_at": "2025-10-01T14:55:32.309387+00:00",
  "note": "Replace this simulation with real image generation output."
}
===== END FILE: outputs\images\de145740-dd58-4a2b-95b6-dff738f318a9.json =====


===== START FILE: outputs\images\e3b6098e-c1fe-4d6a-a845-2690f4c2039b.json =====
{
  "task_id": "e3b6098e-c1fe-4d6a-a845-2690f4c2039b",
  "prompt": "silver ring on velvet",
  "note": "replace with real image path"
}
===== END FILE: outputs\images\e3b6098e-c1fe-4d6a-a845-2690f4c2039b.json =====


===== START FILE: outputs\images\fbfc9d52-b06f-4508-8d14-f6b874622c4d.json =====
{
  "task_id": "fbfc9d52-b06f-4508-8d14-f6b874622c4d",
  "prompt": "glass teacup on silk",
  "generated_at": "2025-10-01T14:55:33.351420+00:00",
  "note": "Replace this simulation with real image generation output."
}
===== END FILE: outputs\images\fbfc9d52-b06f-4508-8d14-f6b874622c4d.json =====


===== START FILE: scripts\run_local_stack.ps1 =====
# FILE: scripts\run_local_stack.ps1

$ErrorActionPreference = "Stop"

# --- 0) Vars ---------------------------------------------------------------
$ROOT = "D:\whisper-laced"
$env:PYTHONPATH = $ROOT
$env:DATABASE_URL = "sqlite:///D:/whisper-laced/backend/db.sqlite3"
$env:SECRET_KEY   = "THIS_IS_MY_ONE_FIXED_SECRET_ChangeMe_NOW"

# --- 1) Install Memurai (Redis for Windows) if missing ---------------------
function Ensure-Memurai {
  try {
    Get-Service memurai | Out-Null
    Write-Host "[OK] Memurai service already present."
  } catch {
    Write-Host "[INFO] Installing Memurai via winget..."
    try {
      winget install -e --id Memurai.MemuraiDeveloper --accept-package-agreements --accept-source-agreements
    } catch {
      $item = winget search memurai | Select-String -Pattern "Memurai" | Select-Object -First 1
      if (-not $item) { throw "Could not find Memurai in winget search." }
      $id = ($item -split '\s{2,}')[0].Trim()
      if (-not $id) { throw "Could not parse Memurai ID from winget." }
      winget install -e --id $id --accept-package-agreements --accept-source-agreements
    }
  }
}

Ensure-Memurai

# --- 2) Start Memurai (Redis) ----------------------------------------------
try { Start-Service memurai } catch {}
try { Set-Service memurai -StartupType Automatic | Out-Null } catch {}
Write-Host "[OK] Memurai started (Redis @ 127.0.0.1:6379)."

# --- 3) Kill anything holding port 5000 (old uvicorn) ----------------------
$net = (netstat -ano | Select-String ":5000\s+LISTENING") | ForEach-Object {
  ($_ -replace '.*\s(\d+)$','$1')
} | Where-Object { $_ -match '^\d+$' } | Select-Object -Unique
if ($net) {
  Write-Host "[INFO] Killing PID(s) on :5000 -> $($net -join ', ')"
  $net | ForEach-Object { try { taskkill /PID $_ /F | Out-Null } catch {} }
}

# --- 4) Init DB (safe to re-run) ------------------------------------------
Write-Host "[INFO] Ensuring DB schema..."
python -m backend.scripts.init_db

# --- 5) Start API (window 1) ----------------------------------------------
Write-Host "[INFO] Starting API on http://127.0.0.1:5000 ..."
Start-Process powershell -ArgumentList @(
  "-NoExit","-Command",
  "Set-Location `"$ROOT`";",
  "`$env:DATABASE_URL='$env:DATABASE_URL'; `$env:SECRET_KEY='$env:SECRET_KEY';",
  "python -m uvicorn backend.app.main:app --host 127.0.0.1 --port 5000 --reload"
)

# --- 6) Start Celery worker (window 2) -------------------------------------
Write-Host "[INFO] Starting Celery worker (solo pool) ..."
Start-Process powershell -ArgumentList @(
  "-NoExit","-Command",
  "Set-Location `"$ROOT`";",
  "`$env:PYTHONPATH='$ROOT'; `$env:SECRET_KEY='$env:SECRET_KEY';",
  "python -m celery -A backend.celery_app worker -P solo -l info"
)

# --- 7) Quick smoke for Phase 10 (window 3) --------------------------------
if (Test-Path "$ROOT\scripts\smoke_phase10.ps1") {
  Write-Host "[INFO] Launching phase-10 smoke..."
  Start-Process powershell -ArgumentList @(
    "-NoExit","-Command",
    "Set-Location `"$ROOT`"; .\scripts\smoke_phase10.ps1"
  )
} else {
  Write-Host "[WARN] scripts\smoke_phase10.ps1 not found; skipping auto-smoke."
}

# --- 8) Queue a couple Celery jobs (window 4) ------------------------------
Write-Host "[INFO] Queueing demo batch_generate tasks..."
Start-Process powershell -ArgumentList @(
  "-NoExit","-Command",
  "Set-Location `"$ROOT`";",
  "`$env:PYTHONPATH='$ROOT'; `$env:SECRET_KEY='$env:SECRET_KEY';",
  "python -m backend.scripts.batch_generate `"a scented candle`" `"a lace pattern`""
)

Write-Host "`nALL SET:"
Write-Host " - API window: uvicorn running on :5000"
Write-Host " - Worker window: Celery connected to Redis (Memurai)"
Write-Host " - Smoke window: Phase 10 checks"
Write-Host " - Batch window: queued demo tasks"

===== END FILE: scripts\run_local_stack.ps1 =====


===== START FILE: scripts\smoke_phase10.ps1 =====
param([string]$base="http://127.0.0.1:5000")

Write-Host "Health:" (curl.exe -s "$base/health")
Write-Host "Editor ping:" (curl.exe -s "$base/editor/ping")

$doc = @{ title="Smoke Doc"; body="hello world" } | ConvertTo-Json -Compress
$resp = Invoke-RestMethod -Method Post -Uri "$base/editor/documents" -ContentType "application/json" -Body $doc
$docId = $resp.id
Write-Host "Doc created:" ($resp | ConvertTo-Json -Compress)

Write-Host "Doc read:" (curl.exe -s "$base/editor/documents/$docId")
Write-Host "Versions:" (curl.exe -s "$base/editor/documents/$docId/versions")

$enh = @{ instruction="clean up text" } | ConvertTo-Json -Compress
$enhResp = Invoke-RestMethod -Method Post -Uri "$base/editor/documents/$docId/enhance" -ContentType "application/json" -Body $enh
Write-Host "Enhanced:" ($enhResp | ConvertTo-Json -Compress)

Write-Host "Versions after:" (curl.exe -s "$base/editor/documents/$docId/versions")
Write-Host "Enhancements:" (curl.exe -s "$base/enhancements/")

===== END FILE: scripts\smoke_phase10.ps1 =====


===== START FILE: whisper\services\laced_bridge.py =====
import requests


BACKEND_URL = "http://localhost:5000/whisper/prompt"


def send_prompt_to_backend(user_id: int, prompt_text: str, response_text: str = None):
    try:
        payload = {
            "user_id": user_id,
            "prompt_text": prompt_text,
            "response_text": response_text,
        }
        res = requests.post(BACKEND_URL, json=payload)
        res.raise_for_status()
        return res.json()
    except Exception as e:
        print(f"[Whisper ? Laced] Error sending prompt: {e}")
        return None

===== END FILE: whisper\services\laced_bridge.py =====
